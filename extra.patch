Index: pp-trace/ArgTokens.cpp
===================================================================
--- pp-trace/ArgTokens.cpp	(nonexistent)
+++ pp-trace/ArgTokens.cpp	(working copy)
@@ -0,0 +1,40 @@
+#include "ArgTokens.h"
+
+void ArgTokens::Init(const MacroDefinition &MD,
+  const clang::MacroArgs *ActArgs, clang::Preprocessor& PP,	bool BuildCache) {
+
+  if (!ActArgs) {
+    return;
+  }
+
+	if (IsInitialized()) {
+		Destroy();
+	}
+
+  const auto DefArgs = MD.getMacroInfo()->args();
+
+	for (auto I = 0u, E = ActArgs->getNumArguments(); I < E; ++I) {
+		auto Current = ActArgs->getUnexpArgument(I);
+		auto TokenCount = ActArgs->getArgLength(Current) + 1; // include EOF
+		E -= TokenCount;
+
+		// We're assuming tokens are contiguous, as otherwise we have no
+		// other way to get at them.
+		--TokenCount;
+
+		if (BuildCache) {
+      Cache.push_back(std::make_tuple(DefArgs[I]->getName(),
+        std::tuple_element<1, decltype(Cache)::value_type>::type()));
+		}
+		for (auto TokenIndex = 0u; TokenIndex < TokenCount; ++TokenIndex, ++Current) {
+			if (BuildCache) {
+				std::get<1>(Cache.back()).push_back(PP.getSpelling(*Current));
+			}
+		}
+	}
+}
+
+void ArgTokens::Destroy() {
+	Cache.clear();
+}
+
Index: pp-trace/ArgTokens.h
===================================================================
--- pp-trace/ArgTokens.h	(nonexistent)
+++ pp-trace/ArgTokens.h	(working copy)
@@ -0,0 +1,39 @@
+#ifndef PPTRACE_ARGTOKENS_H
+#define PPTRACE_ARGTOKENS_H
+
+#include "clang/Lex/Preprocessor.h"
+#include "clang/Lex/MacroArgs.h"
+
+#include <vector>
+
+using namespace clang;
+
+class ArgTokens {
+private:
+
+  // A vector of tuples of strings(definition arg) and vectors of (actual args)
+	std::vector<
+    std::tuple<
+      std::string,
+      std::vector<std::string>
+    >
+  > Cache;
+
+	//ArgTokens(const ArgTokens& other) = delete;
+
+public:
+
+	void Init(const MacroDefinition &MacroDefinition, const MacroArgs *ActualArgs,
+    Preprocessor& PP, bool BuildCache);
+
+	auto begin() const { return Cache.cbegin(); }
+	auto end() const { return Cache.cend(); }
+  auto size() const { return Cache.size(); }
+
+  auto IsInitialized() const { return !Cache.empty(); }
+
+	void Destroy();
+};
+
+
+#endif // PPTRACE_ARGTOKENS_H
\ No newline at end of file
Index: pp-trace/CallbackCall.h
===================================================================
--- pp-trace/CallbackCall.h	(nonexistent)
+++ pp-trace/CallbackCall.h	(working copy)
@@ -0,0 +1,130 @@
+#ifndef PPTRACE_CALLBACKCALL_H
+#define PPTRACE_CALLBACKCALL_H
+
+#include "ArgTokens.h"
+#include "llvm/ADT/StringRef.h"
+#include "llvm/ADT/SmallSet.h"
+#include "clang/Lex/Preprocessor.h"
+#include "clang/Lex/MacroArgs.h"
+#include <string>
+#include <vector>
+
+
+/// \brief This class represents one callback function argument by name
+///   and value.
+class Argument {
+public:
+  Argument(llvm::StringRef Name, llvm::StringRef Value)
+      : Name(Name), Value(Value) {}
+  Argument() = default;
+
+  std::string Name;
+  std::string Value;
+};
+
+/// \brief This class represents one callback call by name and an array
+///   of arguments.
+class CallbackCall {
+public:
+  CallbackCall(llvm::StringRef Name) : Name(Name) {}
+  CallbackCall() = default;
+
+  std::string Name;
+  std::vector<Argument> Arguments;
+};
+
+class CallbackCalls {
+
+protected:
+	/// \brief Inhibit trace while this is set.
+	bool DisableTrace;
+
+public:
+	CallbackCalls(llvm::SmallSet<std::string, 4> &Ignore);
+	virtual ~CallbackCalls() {}
+
+	auto begin() const { return Calls.cbegin(); }
+	auto end() const { return Calls.cend(); }
+
+	/// \brief Start a new callback.
+	void beginCallback(const char *Name);
+
+	/// \brief Append a bool argument to the top trace item.
+	virtual void appendArgument(const char *Name, bool Value);
+
+	/// \brief Append an int argument to the top trace item.
+	virtual void appendArgument(const char *Name, int Value);
+
+	/// \brief Append a string argument to the top trace item.
+	virtual void appendArgument(const char *Name, const char *Value);
+
+	/// \brief Append a string reference object argument to the top trace item.
+	virtual void appendArgument(const char *Name, llvm::StringRef Value);
+
+	/// \brief Append a string object argument to the top trace item.
+	virtual void appendArgument(const char *Name, const std::string &Value);
+
+	/// \brief Append a token argument to the top trace item.
+	virtual void appendArgument(const char *Name, const clang::Token &Value, clang::Preprocessor& PP);
+
+	/// \brief Append an enum argument to the top trace item.
+	virtual void appendArgument(const char *Name, int Value, const char *const Strings[]);
+
+	/// \brief Append a FileID argument to the top trace item.
+	virtual void appendArgument(const char *Name, clang::FileID Value, clang::Preprocessor& PP);
+
+	/// \brief Append a FileEntry argument to the top trace item.
+	virtual void appendArgument(const char *Name, const clang::FileEntry *Value);
+
+	/// \brief Append a SourceLocation argument to the top trace item.
+	virtual void appendArgument(const char *Name, clang::SourceLocation Value, clang::Preprocessor& PP);
+
+	/// \brief Append a SourceRange argument to the top trace item.
+	virtual void appendArgument(const char *Name, clang::SourceRange Value, clang::Preprocessor& PP);
+
+	/// \brief Append a CharSourceRange argument to the top trace item.
+	virtual void appendArgument(const char *Name, clang::CharSourceRange Value, clang::Preprocessor& PP);
+
+	/// \brief Append a ModuleIdPath argument to the top trace item.
+	virtual void appendArgument(const char *Name, clang::ModuleIdPath Value, clang::Preprocessor& PP);
+
+	/// \brief Append an IdentifierInfo argument to the top trace item.
+	virtual void appendArgument(const char *Name, const clang::IdentifierInfo *Value);
+
+	/// \brief Append a MacroDirective argument to the top trace item.
+	virtual void appendArgument(const char *Name, const clang::MacroDirective *Value);
+
+	/// \brief Append a MacroDefinition argument to the top trace item.
+	virtual void appendArgument(const char *Name, const clang::MacroDefinition &Value);
+
+	/// \brief Append a Module argument to the top trace item.
+	virtual void appendArgument(const char *Name, const clang::Module *Value);
+
+  virtual void appendArgument(const char *Name, const ArgTokens *Args);
+
+	/// \brief Append a double-quoted argument to the top trace item.
+	void appendQuotedArgument(const char *Name, const std::string &Value);
+
+	/// \brief Append a double-quoted file path argument to the top trace item.
+	void appendFilePathArgument(const char *Name, llvm::StringRef Value);
+
+private:
+
+	/// \brief Callback trace information.
+	/// We use a reference so the trace will be preserved for the caller
+	/// after this object is destructed.
+	std::vector<CallbackCall> Calls;
+
+	/// \brief Names of callbacks to ignore.
+	llvm::SmallSet<std::string, 4> &Ignore;
+};
+
+
+class CallbackCallsVerbose : public CallbackCalls {
+public:
+	CallbackCallsVerbose(llvm::SmallSet<std::string, 4> &Ignore) : CallbackCalls(Ignore) {}
+	virtual ~CallbackCallsVerbose() {}
+	virtual void appendArgument(const char *Name, clang::SourceRange Value, clang::Preprocessor& PP) override;
+};
+
+#endif PPTRACE_CALLBACKCALL_H // PPTRACE_CALLBACKCALL_H
\ No newline at end of file
Index: pp-trace/CallbackCalls.cpp
===================================================================
--- pp-trace/CallbackCalls.cpp	(nonexistent)
+++ pp-trace/CallbackCalls.cpp	(working copy)
@@ -0,0 +1,257 @@
+#include "CallbackCall.h"
+#include "Utils.h"
+#include "clang/Lex/Preprocessor.h"
+
+
+// MacroDirective::Kind strings.
+static const char *const MacroDirectiveKindStrings[] = {
+	"MD_Define", "MD_Undefine", "MD_Visibility"
+};
+
+CallbackCalls::CallbackCalls(llvm::SmallSet<std::string, 4> &Ignore)
+	: Ignore(Ignore) { }
+
+// Start a new callback.
+void CallbackCalls::beginCallback(const char *Name) {
+  DisableTrace = Ignore.count(std::string(Name));
+  if (DisableTrace)
+    return;
+  Calls.push_back(CallbackCall(Name));
+}
+
+// Append a bool argument to the top trace item.
+void CallbackCalls::appendArgument(const char *Name, bool Value) {
+  appendArgument(Name, (Value ? "true" : "false"));
+}
+
+// Append an int argument to the top trace item.
+void CallbackCalls::appendArgument(const char *Name, int Value) {
+  std::string Str;
+  llvm::raw_string_ostream SS(Str);
+  SS << Value;
+  appendArgument(Name, SS.str());
+}
+
+// Append a string argument to the top trace item.
+void CallbackCalls::appendArgument(const char *Name, const char *Value) {
+  if (DisableTrace)
+    return;
+  Calls.back().Arguments.push_back(Argument(Name, Value));
+}
+
+// Append a string object argument to the top trace item.
+void CallbackCalls::appendArgument(const char *Name,
+                                        llvm::StringRef Value) {
+  appendArgument(Name, Value.str());
+}
+
+// Append a string object argument to the top trace item.
+void CallbackCalls::appendArgument(const char *Name,
+                                        const std::string &Value) {
+  appendArgument(Name, Value.c_str());
+}
+
+// Append a token argument to the top trace item.
+void CallbackCalls::appendArgument(const char *Name,
+                                        const clang::Token &Value,
+										clang::Preprocessor& PP) {
+  appendArgument(Name, PP.getSpelling(Value));
+}
+
+// Append an enum argument to the top trace item.
+void CallbackCalls::appendArgument(const char *Name, int Value,
+                                        const char *const Strings[]) {
+  appendArgument(Name, Strings[Value]);
+}
+
+// Append a FileID argument to the top trace item.
+void CallbackCalls::appendArgument(const char *Name, clang::FileID Value,
+										clang::Preprocessor& PP) {
+  if (Value.isInvalid()) {
+    appendArgument(Name, "(invalid)");
+    return;
+  }
+  const clang::FileEntry *FileEntry =
+      PP.getSourceManager().getFileEntryForID(Value);
+  if (!FileEntry) {
+    appendArgument(Name, "(getFileEntryForID failed)");
+    return;
+  }
+  appendFilePathArgument(Name, FileEntry->getName());
+}
+
+// Append a FileEntry argument to the top trace item.
+void CallbackCalls::appendArgument(const char *Name,
+                                        const clang::FileEntry *Value) {
+  if (!Value) {
+    appendArgument(Name, "(null)");
+    return;
+  }
+  appendFilePathArgument(Name, Value->getName());
+}
+
+// Append a SourceLocation argument to the top trace item.
+void CallbackCalls::appendArgument(const char *Name,
+                                        clang::SourceLocation Value,
+										clang::Preprocessor& PP) {
+  if (Value.isInvalid()) {
+    appendArgument(Name, "(invalid)");
+    return;
+  }
+  appendArgument(Name, getSourceLocationString(PP, Value).c_str());
+}
+
+// Append a SourceRange argument to the top trace item.
+void CallbackCalls::appendArgument(const char *Name,
+                                        clang::SourceRange Value,
+										clang::Preprocessor& PP) {
+  if (DisableTrace)
+    return;
+  if (Value.isInvalid()) {
+    appendArgument(Name, "(invalid)");
+    return;
+  }
+  std::string Str;
+  llvm::raw_string_ostream SS(Str);
+  SS << "[" << getSourceLocationString(PP, Value.getBegin()) << ", "
+     << getSourceLocationString(PP, Value.getEnd()) << "]";
+  appendArgument(Name, SS.str());
+}
+
+// Append a CharSourceRange argument to the top trace item.
+void CallbackCalls::appendArgument(const char *Name,
+                                        clang::CharSourceRange Value,
+										clang::Preprocessor& PP) {
+  if (Value.isInvalid()) {
+    appendArgument(Name, "(invalid)");
+    return;
+  }
+  appendArgument(Name, getSourceString<clang::CharSourceRange>(PP, Value).str().c_str());
+}
+
+// Append a SourceLocation argument to the top trace item.
+void CallbackCalls::appendArgument(const char *Name,
+                                        clang::ModuleIdPath Value,
+										clang::Preprocessor& PP) {
+  if (DisableTrace)
+    return;
+  std::string Str;
+  llvm::raw_string_ostream SS(Str);
+  SS << "[";
+  for (int I = 0, E = Value.size(); I != E; ++I) {
+    if (I)
+      SS << ", ";
+    SS << "{"
+       << "Name: " << Value[I].first->getName() << ", "
+       << "Loc: " << getSourceLocationString(PP, Value[I].second) << "}";
+  }
+  SS << "]";
+  appendArgument(Name, SS.str());
+}
+
+// Append an IdentifierInfo argument to the top trace item.
+void CallbackCalls::appendArgument(const char *Name,
+                                        const clang::IdentifierInfo *Value) {
+  if (!Value) {
+    appendArgument(Name, "(null)");
+    return;
+  }
+  appendArgument(Name, Value->getName().str().c_str());
+}
+
+// Append a MacroDirective argument to the top trace item.
+void CallbackCalls::appendArgument(const char *Name,
+                                        const clang::MacroDirective *Value) {
+  if (!Value) {
+    appendArgument(Name, "(null)");
+    return;
+  }
+  appendArgument(Name, MacroDirectiveKindStrings[Value->getKind()]);
+}
+
+// Append a MacroDefinition argument to the top trace item.
+void CallbackCalls::appendArgument(const char *Name,
+                                        const clang::MacroDefinition &Value) {
+  std::string Str;
+  llvm::raw_string_ostream SS(Str);
+  SS << "[";
+  bool Any = false;
+  if (Value.getLocalDirective()) {
+    SS << "(local)";
+    Any = true;
+  }
+  for (auto *MM : Value.getModuleMacros()) {
+    if (Any) SS << ", ";
+    SS << MM->getOwningModule()->getFullModuleName();
+  }
+  SS << "]";
+  appendArgument(Name, SS.str());
+}
+
+// Append a Module argument to the top trace item.
+void CallbackCalls::appendArgument(const char *Name,
+                                        const clang::Module *Value) {
+  if (!Value) {
+    appendArgument(Name, "(null)");
+    return;
+  }
+  appendArgument(Name, Value->Name.c_str());
+}
+
+void CallbackCalls::appendArgument(const char *Name, const ArgTokens *Args) {
+  std::string s;
+  llvm::raw_string_ostream SS(s);
+  for (const auto& arg : *Args) {
+    SS << "\n  - ";
+    SS << std::get<0>(arg) << ": ";
+    const auto& subargs = std::get<1>(arg);
+    for (auto subarg = subargs.cbegin(); subarg < subargs.cend(); ++subarg) {
+      SS << *subarg;
+    }
+  }
+
+  appendArgument(Name, SS.str());
+}
+
+// Append a double-quoted argument to the top trace item.
+void CallbackCalls::appendQuotedArgument(const char *Name,
+                                              const std::string &Value) {
+  std::string Str;
+  llvm::raw_string_ostream SS(Str);
+  SS << "\"" << Value << "\"";
+  appendArgument(Name, SS.str());
+}
+
+// Append a double-quoted file path argument to the top trace item.
+void CallbackCalls::appendFilePathArgument(const char *Name,
+                                                llvm::StringRef Value) {
+  std::string Path(Value);
+  // YAML treats backslash as escape, so use forward slashes.
+  std::replace(Path.begin(), Path.end(), '\\', '/');
+  appendQuotedArgument(Name, Path);
+}
+
+void CallbackCallsVerbose::appendArgument(const char *Name,
+	clang::SourceRange Value, clang::Preprocessor& PP) {
+	if (DisableTrace)
+		return;
+	if (Value.isInvalid()) {
+		CallbackCalls::appendArgument(Name, "(invalid)");
+		return;
+	}
+	std::string Str;
+	const auto sourceStr = getSourceString<clang::SourceRange>(PP, Value);
+
+	llvm::raw_string_ostream SS(Str);
+	SS << "[" << getSourceLocationString(PP, Value.getBegin()) << ", "
+		<< getSourceLocationString(PP, Value.getEnd()) << "]\n    ";
+
+	if (sourceStr.size()) {
+		for (auto i = 0u; i < strlen(Name); ++i) {
+			SS << " ";
+		}
+
+		SS << sourceStr;
+	}
+	CallbackCalls::appendArgument(Name, SS.str());
+}
\ No newline at end of file
Index: pp-trace/CMakeLists.txt
===================================================================
--- pp-trace/CMakeLists.txt	(revision 302379)
+++ pp-trace/CMakeLists.txt	(working copy)
@@ -5,6 +5,9 @@
 add_clang_executable(pp-trace
   PPTrace.cpp
   PPCallbacksTracker.cpp
+  PPCallbacksVerbose.cpp
+  CallbackCalls.cpp
+  ArgTokens.cpp
   )
 
 target_link_libraries(pp-trace
Index: pp-trace/PPCallbacksTracker.cpp
===================================================================
--- pp-trace/PPCallbacksTracker.cpp	(revision 302379)
+++ pp-trace/PPCallbacksTracker.cpp	(working copy)
@@ -1,654 +1,382 @@
-//===--- PPCallbacksTracker.cpp - Preprocessor tracker -*--*---------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-///
-/// \file
-/// \brief Implementations for preprocessor tracking.
-///
-/// See the header for details.
-///
-//===----------------------------------------------------------------------===//
-
-#include "PPCallbacksTracker.h"
-#include "clang/Lex/MacroArgs.h"
-#include "llvm/Support/raw_ostream.h"
-
-// Utility functions.
-
-// Get a "file:line:column" source location string.
-static std::string getSourceLocationString(clang::Preprocessor &PP,
-                                           clang::SourceLocation Loc) {
-  if (Loc.isInvalid())
-    return std::string("(none)");
-
-  if (Loc.isFileID()) {
-    clang::PresumedLoc PLoc = PP.getSourceManager().getPresumedLoc(Loc);
-
-    if (PLoc.isInvalid()) {
-      return std::string("(invalid)");
-    }
-
-    std::string Str;
-    llvm::raw_string_ostream SS(Str);
-
-    // The macro expansion and spelling pos is identical for file locs.
-    SS << "\"" << PLoc.getFilename() << ':' << PLoc.getLine() << ':'
-       << PLoc.getColumn() << "\"";
-
-    std::string Result = SS.str();
-
-    // YAML treats backslash as escape, so use forward slashes.
-    std::replace(Result.begin(), Result.end(), '\\', '/');
-
-    return Result;
-  }
-
-  return std::string("(nonfile)");
-}
-
-// Enum string tables.
-
-// FileChangeReason strings.
-static const char *const FileChangeReasonStrings[] = {
-  "EnterFile", "ExitFile", "SystemHeaderPragma", "RenameFile"
-};
-
-// CharacteristicKind strings.
-static const char *const CharacteristicKindStrings[] = { "C_User", "C_System",
-                                                         "C_ExternCSystem" };
-
-// MacroDirective::Kind strings.
-static const char *const MacroDirectiveKindStrings[] = {
-  "MD_Define","MD_Undefine", "MD_Visibility"
-};
-
-// PragmaIntroducerKind strings.
-static const char *const PragmaIntroducerKindStrings[] = { "PIK_HashPragma",
-                                                           "PIK__Pragma",
-                                                           "PIK___pragma" };
-
-// PragmaMessageKind strings.
-static const char *const PragmaMessageKindStrings[] = {
-  "PMK_Message", "PMK_Warning", "PMK_Error"
-};
-
-// ConditionValueKind strings.
-static const char *const ConditionValueKindStrings[] = {
-  "CVK_NotEvaluated", "CVK_False", "CVK_True"
-};
-
-// Mapping strings.
-static const char *const MappingStrings[] = { "0",          "MAP_IGNORE",
-                                              "MAP_REMARK", "MAP_WARNING",
-                                              "MAP_ERROR",  "MAP_FATAL" };
-
-// PPCallbacksTracker functions.
-
-PPCallbacksTracker::PPCallbacksTracker(llvm::SmallSet<std::string, 4> &Ignore,
-                                       std::vector<CallbackCall> &CallbackCalls,
-                                       clang::Preprocessor &PP)
-    : CallbackCalls(CallbackCalls), Ignore(Ignore), PP(PP) {}
-
-PPCallbacksTracker::~PPCallbacksTracker() {}
-
-// Callback functions.
-
-// Callback invoked whenever a source file is entered or exited.
-void PPCallbacksTracker::FileChanged(
-    clang::SourceLocation Loc, clang::PPCallbacks::FileChangeReason Reason,
-    clang::SrcMgr::CharacteristicKind FileType, clang::FileID PrevFID) {
-  beginCallback("FileChanged");
-  appendArgument("Loc", Loc);
-  appendArgument("Reason", Reason, FileChangeReasonStrings);
-  appendArgument("FileType", FileType, CharacteristicKindStrings);
-  appendArgument("PrevFID", PrevFID);
-}
-
-// Callback invoked whenever a source file is skipped as the result
-// of header guard optimization.
-void
-PPCallbacksTracker::FileSkipped(const clang::FileEntry &SkippedFile,
-                                const clang::Token &FilenameTok,
-                                clang::SrcMgr::CharacteristicKind FileType) {
-  beginCallback("FileSkipped");
-  appendArgument("ParentFile", &SkippedFile);
-  appendArgument("FilenameTok", FilenameTok);
-  appendArgument("FileType", FileType, CharacteristicKindStrings);
-}
-
-// Callback invoked whenever an inclusion directive results in a
-// file-not-found error.
-bool
-PPCallbacksTracker::FileNotFound(llvm::StringRef FileName,
-                                 llvm::SmallVectorImpl<char> &RecoveryPath) {
-  beginCallback("FileNotFound");
-  appendFilePathArgument("FileName", FileName);
-  return false;
-}
-
-// Callback invoked whenever an inclusion directive of
-// any kind (#include, #import, etc.) has been processed, regardless
-// of whether the inclusion will actually result in an inclusion.
-void PPCallbacksTracker::InclusionDirective(
-    clang::SourceLocation HashLoc, const clang::Token &IncludeTok,
-    llvm::StringRef FileName, bool IsAngled,
-    clang::CharSourceRange FilenameRange, const clang::FileEntry *File,
-    llvm::StringRef SearchPath, llvm::StringRef RelativePath,
-    const clang::Module *Imported) {
-  beginCallback("InclusionDirective");
-  appendArgument("IncludeTok", IncludeTok);
-  appendFilePathArgument("FileName", FileName);
-  appendArgument("IsAngled", IsAngled);
-  appendArgument("FilenameRange", FilenameRange);
-  appendArgument("File", File);
-  appendFilePathArgument("SearchPath", SearchPath);
-  appendFilePathArgument("RelativePath", RelativePath);
-  appendArgument("Imported", Imported);
-}
-
-// Callback invoked whenever there was an explicit module-import
-// syntax.
-void PPCallbacksTracker::moduleImport(clang::SourceLocation ImportLoc,
-                                      clang::ModuleIdPath Path,
-                                      const clang::Module *Imported) {
-  beginCallback("moduleImport");
-  appendArgument("ImportLoc", ImportLoc);
-  appendArgument("Path", Path);
-  appendArgument("Imported", Imported);
-}
-
-// Callback invoked when the end of the main file is reached.
-// No subsequent callbacks will be made.
-void PPCallbacksTracker::EndOfMainFile() { beginCallback("EndOfMainFile"); }
-
-// Callback invoked when a #ident or #sccs directive is read.
-void PPCallbacksTracker::Ident(clang::SourceLocation Loc, llvm::StringRef Str) {
-  beginCallback("Ident");
-  appendArgument("Loc", Loc);
-  appendArgument("Str", Str);
-}
-
-// Callback invoked when start reading any pragma directive.
-void
-PPCallbacksTracker::PragmaDirective(clang::SourceLocation Loc,
-                                    clang::PragmaIntroducerKind Introducer) {
-  beginCallback("PragmaDirective");
-  appendArgument("Loc", Loc);
-  appendArgument("Introducer", Introducer, PragmaIntroducerKindStrings);
-}
-
-// Callback invoked when a #pragma comment directive is read.
-void PPCallbacksTracker::PragmaComment(clang::SourceLocation Loc,
-                                       const clang::IdentifierInfo *Kind,
-                                       llvm::StringRef Str) {
-  beginCallback("PragmaComment");
-  appendArgument("Loc", Loc);
-  appendArgument("Kind", Kind);
-  appendArgument("Str", Str);
-}
-
-// Callback invoked when a #pragma detect_mismatch directive is
-// read.
-void PPCallbacksTracker::PragmaDetectMismatch(clang::SourceLocation Loc,
-                                              llvm::StringRef Name,
-                                              llvm::StringRef Value) {
-  beginCallback("PragmaDetectMismatch");
-  appendArgument("Loc", Loc);
-  appendArgument("Name", Name);
-  appendArgument("Value", Value);
-}
-
-// Callback invoked when a #pragma clang __debug directive is read.
-void PPCallbacksTracker::PragmaDebug(clang::SourceLocation Loc,
-                                     llvm::StringRef DebugType) {
-  beginCallback("PragmaDebug");
-  appendArgument("Loc", Loc);
-  appendArgument("DebugType", DebugType);
-}
-
-// Callback invoked when a #pragma message directive is read.
-void PPCallbacksTracker::PragmaMessage(
-    clang::SourceLocation Loc, llvm::StringRef Namespace,
-    clang::PPCallbacks::PragmaMessageKind Kind, llvm::StringRef Str) {
-  beginCallback("PragmaMessage");
-  appendArgument("Loc", Loc);
-  appendArgument("Namespace", Namespace);
-  appendArgument("Kind", Kind, PragmaMessageKindStrings);
-  appendArgument("Str", Str);
-}
-
-// Callback invoked when a #pragma gcc dianostic push directive
-// is read.
-void PPCallbacksTracker::PragmaDiagnosticPush(clang::SourceLocation Loc,
-                                              llvm::StringRef Namespace) {
-  beginCallback("PragmaDiagnosticPush");
-  appendArgument("Loc", Loc);
-  appendArgument("Namespace", Namespace);
-}
-
-// Callback invoked when a #pragma gcc dianostic pop directive
-// is read.
-void PPCallbacksTracker::PragmaDiagnosticPop(clang::SourceLocation Loc,
-                                             llvm::StringRef Namespace) {
-  beginCallback("PragmaDiagnosticPop");
-  appendArgument("Loc", Loc);
-  appendArgument("Namespace", Namespace);
-}
-
-// Callback invoked when a #pragma gcc dianostic directive is read.
-void PPCallbacksTracker::PragmaDiagnostic(clang::SourceLocation Loc,
-                                          llvm::StringRef Namespace,
-                                          clang::diag::Severity Mapping,
-                                          llvm::StringRef Str) {
-  beginCallback("PragmaDiagnostic");
-  appendArgument("Loc", Loc);
-  appendArgument("Namespace", Namespace);
-  appendArgument("Mapping", (unsigned)Mapping, MappingStrings);
-  appendArgument("Str", Str);
-}
-
-// Called when an OpenCL extension is either disabled or
-// enabled with a pragma.
-void PPCallbacksTracker::PragmaOpenCLExtension(
-    clang::SourceLocation NameLoc, const clang::IdentifierInfo *Name,
-    clang::SourceLocation StateLoc, unsigned State) {
-  beginCallback("PragmaOpenCLExtension");
-  appendArgument("NameLoc", NameLoc);
-  appendArgument("Name", Name);
-  appendArgument("StateLoc", StateLoc);
-  appendArgument("State", (int)State);
-}
-
-// Callback invoked when a #pragma warning directive is read.
-void PPCallbacksTracker::PragmaWarning(clang::SourceLocation Loc,
-                                       llvm::StringRef WarningSpec,
-                                       llvm::ArrayRef<int> Ids) {
-  beginCallback("PragmaWarning");
-  appendArgument("Loc", Loc);
-  appendArgument("WarningSpec", WarningSpec);
-
-  std::string Str;
-  llvm::raw_string_ostream SS(Str);
-  SS << "[";
-  for (int i = 0, e = Ids.size(); i != e; ++i) {
-    if (i)
-      SS << ", ";
-    SS << Ids[i];
-  }
-  SS << "]";
-  appendArgument("Ids", SS.str());
-}
-
-// Callback invoked when a #pragma warning(push) directive is read.
-void PPCallbacksTracker::PragmaWarningPush(clang::SourceLocation Loc,
-                                           int Level) {
-  beginCallback("PragmaWarningPush");
-  appendArgument("Loc", Loc);
-  appendArgument("Level", Level);
-}
-
-// Callback invoked when a #pragma warning(pop) directive is read.
-void PPCallbacksTracker::PragmaWarningPop(clang::SourceLocation Loc) {
-  beginCallback("PragmaWarningPop");
-  appendArgument("Loc", Loc);
-}
-
-// Called by Preprocessor::HandleMacroExpandedIdentifier when a
-// macro invocation is found.
-void
-PPCallbacksTracker::MacroExpands(const clang::Token &MacroNameTok,
-                                 const clang::MacroDefinition &MacroDefinition,
-                                 clang::SourceRange Range,
-                                 const clang::MacroArgs *Args) {
-  beginCallback("MacroExpands");
-  appendArgument("MacroNameTok", MacroNameTok);
-  appendArgument("MacroDefinition", MacroDefinition);
-  appendArgument("Range", Range);
-  appendArgument("Args", Args);
-}
-
-// Hook called whenever a macro definition is seen.
-void
-PPCallbacksTracker::MacroDefined(const clang::Token &MacroNameTok,
-                                 const clang::MacroDirective *MacroDirective) {
-  beginCallback("MacroDefined");
-  appendArgument("MacroNameTok", MacroNameTok);
-  appendArgument("MacroDirective", MacroDirective);
-}
-
-// Hook called whenever a macro #undef is seen.
-void PPCallbacksTracker::MacroUndefined(
-    const clang::Token &MacroNameTok,
+//===--- PPCallbacksTracker.cpp - Preprocessor tracker -*--*---------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+///
+/// \file
+/// \brief Implementations for preprocessor tracking.
+///
+/// See the header for details.
+///
+//===----------------------------------------------------------------------===//
+
+#include "PPCallbacksTracker.h"
+#include "llvm/Support/raw_ostream.h"
+
+
+// Enum string tables.
+
+// FileChangeReason strings.
+static const char *const FileChangeReasonStrings[] = {
+  "EnterFile", "ExitFile", "SystemHeaderPragma", "RenameFile"
+};
+
+// CharacteristicKind strings.
+static const char *const CharacteristicKindStrings[] = { "C_User", "C_System",
+                                                         "C_ExternCSystem" };
+
+
+// PragmaIntroducerKind strings.
+static const char *const PragmaIntroducerKindStrings[] = { "PIK_HashPragma",
+                                                           "PIK__Pragma",
+                                                           "PIK___pragma" };
+
+// PragmaMessageKind strings.
+static const char *const PragmaMessageKindStrings[] = {
+  "PMK_Message", "PMK_Warning", "PMK_Error"
+};
+
+// ConditionValueKind strings.
+static const char *const ConditionValueKindStrings[] = {
+  "CVK_NotEvaluated", "CVK_False", "CVK_True"
+};
+
+// Mapping strings.
+static const char *const MappingStrings[] = { "0",          "MAP_IGNORE",
+                                              "MAP_REMARK", "MAP_WARNING",
+                                              "MAP_ERROR",  "MAP_FATAL" };
+
+// PPCallbacksTracker functions.
+
+PPCallbacksTracker::PPCallbacksTracker(CallbackCalls &CallbackCalls,
+                                       clang::Preprocessor &PP)
+    : Calls(CallbackCalls), PP(PP) {}
+
+PPCallbacksTracker::~PPCallbacksTracker() {}
+
+// Callback functions.
+
+// Callback invoked whenever a source file is entered or exited.
+void PPCallbacksTracker::FileChanged(
+    clang::SourceLocation Loc, clang::PPCallbacks::FileChangeReason Reason,
+    clang::SrcMgr::CharacteristicKind FileType, clang::FileID PrevFID) {
+  Calls.beginCallback("FileChanged");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("Reason", Reason, FileChangeReasonStrings);
+  Calls.appendArgument("FileType", FileType, CharacteristicKindStrings);
+  Calls.appendArgument("PrevFID", PrevFID, PP);
+}
+
+// Callback invoked whenever a source file is skipped as the result
+// of header guard optimization.
+void
+PPCallbacksTracker::FileSkipped(const clang::FileEntry &SkippedFile,
+                                const clang::Token &FilenameTok,
+                                clang::SrcMgr::CharacteristicKind FileType) {
+  Calls.beginCallback("FileSkipped");
+  Calls.appendArgument("ParentFile", &SkippedFile);
+  Calls.appendArgument("FilenameTok", FilenameTok, PP);
+  Calls.appendArgument("FileType", FileType, CharacteristicKindStrings);
+}
+
+// Callback invoked whenever an inclusion directive results in a
+// file-not-found error.
+bool
+PPCallbacksTracker::FileNotFound(llvm::StringRef FileName,
+                                 llvm::SmallVectorImpl<char> &RecoveryPath) {
+  Calls.beginCallback("FileNotFound");
+  Calls.appendFilePathArgument("FileName", FileName);
+  return false;
+}
+
+// Callback invoked whenever an inclusion directive of
+// any kind (#include, #import, etc.) has been processed, regardless
+// of whether the inclusion will actually result in an inclusion.
+void PPCallbacksTracker::InclusionDirective(
+    clang::SourceLocation HashLoc, const clang::Token &IncludeTok,
+    llvm::StringRef FileName, bool IsAngled,
+    clang::CharSourceRange FilenameRange, const clang::FileEntry *File,
+    llvm::StringRef SearchPath, llvm::StringRef RelativePath,
+    const clang::Module *Imported) {
+  Calls.beginCallback("InclusionDirective");
+  Calls.appendArgument("IncludeTok", IncludeTok, PP);
+  Calls.appendFilePathArgument("FileName", FileName);
+  Calls.appendArgument("IsAngled", IsAngled);
+  Calls.appendArgument("FilenameRange", FilenameRange, PP);
+  Calls.appendArgument("File", File);
+  Calls.appendFilePathArgument("SearchPath", SearchPath);
+  Calls.appendFilePathArgument("RelativePath", RelativePath);
+  Calls.appendArgument("Imported", Imported);
+}
+
+// Callback invoked whenever there was an explicit module-import
+// syntax.
+void PPCallbacksTracker::moduleImport(clang::SourceLocation ImportLoc,
+                                      clang::ModuleIdPath Path,
+                                      const clang::Module *Imported) {
+  Calls.beginCallback("moduleImport");
+  Calls.appendArgument("ImportLoc", ImportLoc, PP);
+  Calls.appendArgument("Path", Path, PP);
+  Calls.appendArgument("Imported", Imported);
+}
+
+// Callback invoked when the end of the main file is reached.
+// No subsequent callbacks will be made.
+void PPCallbacksTracker::EndOfMainFile() { Calls.beginCallback("EndOfMainFile"); }
+
+// Callback invoked when a #ident or #sccs directive is read.
+void PPCallbacksTracker::Ident(clang::SourceLocation Loc, llvm::StringRef Str) {
+  Calls.beginCallback("Ident");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("Str", Str);
+}
+
+// Callback invoked when start reading any pragma directive.
+void
+PPCallbacksTracker::PragmaDirective(clang::SourceLocation Loc,
+                                    clang::PragmaIntroducerKind Introducer) {
+  Calls.beginCallback("PragmaDirective");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("Introducer", Introducer, PragmaIntroducerKindStrings);
+}
+
+// Callback invoked when a #pragma comment directive is read.
+void PPCallbacksTracker::PragmaComment(clang::SourceLocation Loc,
+                                       const clang::IdentifierInfo *Kind,
+                                       llvm::StringRef Str) {
+  Calls.beginCallback("PragmaComment");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("Kind", Kind);
+  Calls.appendArgument("Str", Str);
+}
+
+// Callback invoked when a #pragma detect_mismatch directive is
+// read.
+void PPCallbacksTracker::PragmaDetectMismatch(clang::SourceLocation Loc,
+                                              llvm::StringRef Name,
+                                              llvm::StringRef Value) {
+  Calls.beginCallback("PragmaDetectMismatch");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("Name", Name);
+  Calls.appendArgument("Value", Value);
+}
+
+// Callback invoked when a #pragma clang __debug directive is read.
+void PPCallbacksTracker::PragmaDebug(clang::SourceLocation Loc,
+                                     llvm::StringRef DebugType) {
+  Calls.beginCallback("PragmaDebug");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("DebugType", DebugType);
+}
+
+// Callback invoked when a #pragma message directive is read.
+void PPCallbacksTracker::PragmaMessage(
+    clang::SourceLocation Loc, llvm::StringRef Namespace,
+    clang::PPCallbacks::PragmaMessageKind Kind, llvm::StringRef Str) {
+  Calls.beginCallback("PragmaMessage");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("Namespace", Namespace);
+  Calls.appendArgument("Kind", Kind, PragmaMessageKindStrings);
+  Calls.appendArgument("Str", Str);
+}
+
+// Callback invoked when a #pragma gcc dianostic push directive
+// is read.
+void PPCallbacksTracker::PragmaDiagnosticPush(clang::SourceLocation Loc,
+                                              llvm::StringRef Namespace) {
+  Calls.beginCallback("PragmaDiagnosticPush");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("Namespace", Namespace);
+}
+
+// Callback invoked when a #pragma gcc dianostic pop directive
+// is read.
+void PPCallbacksTracker::PragmaDiagnosticPop(clang::SourceLocation Loc,
+                                             llvm::StringRef Namespace) {
+  Calls.beginCallback("PragmaDiagnosticPop");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("Namespace", Namespace);
+}
+
+// Callback invoked when a #pragma gcc dianostic directive is read.
+void PPCallbacksTracker::PragmaDiagnostic(clang::SourceLocation Loc,
+                                          llvm::StringRef Namespace,
+                                          clang::diag::Severity Mapping,
+                                          llvm::StringRef Str) {
+  Calls.beginCallback("PragmaDiagnostic");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("Namespace", Namespace);
+  Calls.appendArgument("Mapping", (unsigned)Mapping, MappingStrings);
+  Calls.appendArgument("Str", Str);
+}
+
+// Called when an OpenCL extension is either disabled or
+// enabled with a pragma.
+void PPCallbacksTracker::PragmaOpenCLExtension(
+    clang::SourceLocation NameLoc, const clang::IdentifierInfo *Name,
+    clang::SourceLocation StateLoc, unsigned State) {
+  Calls.beginCallback("PragmaOpenCLExtension");
+  Calls.appendArgument("NameLoc", NameLoc, PP);
+  Calls.appendArgument("Name", Name);
+  Calls.appendArgument("StateLoc", StateLoc, PP);
+  Calls.appendArgument("State", (int)State);
+}
+
+// Callback invoked when a #pragma warning directive is read.
+void PPCallbacksTracker::PragmaWarning(clang::SourceLocation Loc,
+                                       llvm::StringRef WarningSpec,
+                                       llvm::ArrayRef<int> Ids) {
+  Calls.beginCallback("PragmaWarning");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("WarningSpec", WarningSpec);
+
+  std::string Str;
+  llvm::raw_string_ostream SS(Str);
+  SS << "[";
+  for (int i = 0, e = Ids.size(); i != e; ++i) {
+    if (i)
+      SS << ", ";
+    SS << Ids[i];
+  }
+  SS << "]";
+  Calls.appendArgument("Ids", SS.str());
+}
+
+// Callback invoked when a #pragma warning(push) directive is read.
+void PPCallbacksTracker::PragmaWarningPush(clang::SourceLocation Loc,
+                                           int Level) {
+  Calls.beginCallback("PragmaWarningPush");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("Level", Level);
+}
+
+// Callback invoked when a #pragma warning(pop) directive is read.
+void PPCallbacksTracker::PragmaWarningPop(clang::SourceLocation Loc) {
+  Calls.beginCallback("PragmaWarningPop");
+  Calls.appendArgument("Loc", Loc, PP);
+}
+
+// Called by Preprocessor::HandleMacroExpandedIdentifier when a
+// macro invocation is found.
+void
+PPCallbacksTracker::MacroExpands(const clang::Token &MacroNameTok,
+                                 const clang::MacroDefinition &MacroDefinition,
+                                 clang::SourceRange Range,
+                                 const clang::MacroArgs *Args) {
+  Calls.beginCallback("MacroExpands");
+  Calls.appendArgument("MacroNameTok", MacroNameTok, PP);
+  Calls.appendArgument("MacroDefinition", MacroDefinition);
+  Calls.appendArgument("Range", Range, PP);
+
+  if (MacroDefinition.getMacroInfo()->isFunctionLike()) {
+    CurrArgs.Init(MacroDefinition, Args, PP, BuildCache());
+    Calls.appendArgument("Args", &CurrArgs);
+  }
+}
+
+// Hook called whenever a macro definition is seen.
+void
+PPCallbacksTracker::MacroDefined(const clang::Token &MacroNameTok,
+                                 const clang::MacroDirective *MacroDirective) {
+  Calls.beginCallback("MacroDefined");
+  Calls.appendArgument("MacroNameTok", MacroNameTok, PP);
+  Calls.appendArgument("MacroDirective", MacroDirective);
+}
+
+// Hook called whenever a macro #undef is seen.
+void PPCallbacksTracker::MacroUndefined(
+    const clang::Token &MacroNameTok,
     const clang::MacroDefinition &MacroDefinition,
     const clang::MacroDirective *Undef) {
-  beginCallback("MacroUndefined");
-  appendArgument("MacroNameTok", MacroNameTok);
-  appendArgument("MacroDefinition", MacroDefinition);
-}
-
-// Hook called whenever the 'defined' operator is seen.
-void PPCallbacksTracker::Defined(const clang::Token &MacroNameTok,
-                                 const clang::MacroDefinition &MacroDefinition,
-                                 clang::SourceRange Range) {
-  beginCallback("Defined");
-  appendArgument("MacroNameTok", MacroNameTok);
-  appendArgument("MacroDefinition", MacroDefinition);
-  appendArgument("Range", Range);
-}
-
-// Hook called when a source range is skipped.
-void PPCallbacksTracker::SourceRangeSkipped(clang::SourceRange Range) {
-  beginCallback("SourceRangeSkipped");
-  appendArgument("Range", Range);
-}
-
-// Hook called whenever an #if is seen.
-void PPCallbacksTracker::If(clang::SourceLocation Loc,
-                            clang::SourceRange ConditionRange,
-                            ConditionValueKind ConditionValue) {
-  beginCallback("If");
-  appendArgument("Loc", Loc);
-  appendArgument("ConditionRange", ConditionRange);
-  appendArgument("ConditionValue", ConditionValue, ConditionValueKindStrings);
-}
-
-// Hook called whenever an #elif is seen.
-void PPCallbacksTracker::Elif(clang::SourceLocation Loc,
-                              clang::SourceRange ConditionRange,
-                              ConditionValueKind ConditionValue,
-                              clang::SourceLocation IfLoc) {
-  beginCallback("Elif");
-  appendArgument("Loc", Loc);
-  appendArgument("ConditionRange", ConditionRange);
-  appendArgument("ConditionValue", ConditionValue, ConditionValueKindStrings);
-  appendArgument("IfLoc", IfLoc);
-}
-
-// Hook called whenever an #ifdef is seen.
-void PPCallbacksTracker::Ifdef(clang::SourceLocation Loc,
-                               const clang::Token &MacroNameTok,
-                               const clang::MacroDefinition &MacroDefinition) {
-  beginCallback("Ifdef");
-  appendArgument("Loc", Loc);
-  appendArgument("MacroNameTok", MacroNameTok);
-  appendArgument("MacroDefinition", MacroDefinition);
-}
-
-// Hook called whenever an #ifndef is seen.
-void PPCallbacksTracker::Ifndef(clang::SourceLocation Loc,
-                                const clang::Token &MacroNameTok,
-                                const clang::MacroDefinition &MacroDefinition) {
-  beginCallback("Ifndef");
-  appendArgument("Loc", Loc);
-  appendArgument("MacroNameTok", MacroNameTok);
-  appendArgument("MacroDefinition", MacroDefinition);
-}
-
-// Hook called whenever an #else is seen.
-void PPCallbacksTracker::Else(clang::SourceLocation Loc,
-                              clang::SourceLocation IfLoc) {
-  beginCallback("Else");
-  appendArgument("Loc", Loc);
-  appendArgument("IfLoc", IfLoc);
-}
-
-// Hook called whenever an #endif is seen.
-void PPCallbacksTracker::Endif(clang::SourceLocation Loc,
-                               clang::SourceLocation IfLoc) {
-  beginCallback("Endif");
-  appendArgument("Loc", Loc);
-  appendArgument("IfLoc", IfLoc);
-}
-
-// Helper functions.
-
-// Start a new callback.
-void PPCallbacksTracker::beginCallback(const char *Name) {
-  DisableTrace = Ignore.count(std::string(Name));
-  if (DisableTrace)
-    return;
-  CallbackCalls.push_back(CallbackCall(Name));
-}
-
-// Append a bool argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name, bool Value) {
-  appendArgument(Name, (Value ? "true" : "false"));
-}
-
-// Append an int argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name, int Value) {
-  std::string Str;
-  llvm::raw_string_ostream SS(Str);
-  SS << Value;
-  appendArgument(Name, SS.str());
-}
-
-// Append a string argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name, const char *Value) {
-  if (DisableTrace)
-    return;
-  CallbackCalls.back().Arguments.push_back(Argument(Name, Value));
-}
-
-// Append a string object argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name,
-                                        llvm::StringRef Value) {
-  appendArgument(Name, Value.str());
-}
-
-// Append a string object argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name,
-                                        const std::string &Value) {
-  appendArgument(Name, Value.c_str());
-}
-
-// Append a token argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name,
-                                        const clang::Token &Value) {
-  appendArgument(Name, PP.getSpelling(Value));
-}
-
-// Append an enum argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name, int Value,
-                                        const char *const Strings[]) {
-  appendArgument(Name, Strings[Value]);
-}
-
-// Append a FileID argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name, clang::FileID Value) {
-  if (Value.isInvalid()) {
-    appendArgument(Name, "(invalid)");
-    return;
-  }
-  const clang::FileEntry *FileEntry =
-      PP.getSourceManager().getFileEntryForID(Value);
-  if (!FileEntry) {
-    appendArgument(Name, "(getFileEntryForID failed)");
-    return;
-  }
-  appendFilePathArgument(Name, FileEntry->getName());
-}
-
-// Append a FileEntry argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name,
-                                        const clang::FileEntry *Value) {
-  if (!Value) {
-    appendArgument(Name, "(null)");
-    return;
-  }
-  appendFilePathArgument(Name, Value->getName());
-}
-
-// Append a SourceLocation argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name,
-                                        clang::SourceLocation Value) {
-  if (Value.isInvalid()) {
-    appendArgument(Name, "(invalid)");
-    return;
-  }
-  appendArgument(Name, getSourceLocationString(PP, Value).c_str());
-}
-
-// Append a SourceRange argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name,
-                                        clang::SourceRange Value) {
-  if (DisableTrace)
-    return;
-  if (Value.isInvalid()) {
-    appendArgument(Name, "(invalid)");
-    return;
-  }
-  std::string Str;
-  llvm::raw_string_ostream SS(Str);
-  SS << "[" << getSourceLocationString(PP, Value.getBegin()) << ", "
-     << getSourceLocationString(PP, Value.getEnd()) << "]";
-  appendArgument(Name, SS.str());
-}
-
-// Append a CharSourceRange argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name,
-                                        clang::CharSourceRange Value) {
-  if (Value.isInvalid()) {
-    appendArgument(Name, "(invalid)");
-    return;
-  }
-  appendArgument(Name, getSourceString(Value).str().c_str());
-}
-
-// Append a SourceLocation argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name,
-                                        clang::ModuleIdPath Value) {
-  if (DisableTrace)
-    return;
-  std::string Str;
-  llvm::raw_string_ostream SS(Str);
-  SS << "[";
-  for (int I = 0, E = Value.size(); I != E; ++I) {
-    if (I)
-      SS << ", ";
-    SS << "{"
-       << "Name: " << Value[I].first->getName() << ", "
-       << "Loc: " << getSourceLocationString(PP, Value[I].second) << "}";
-  }
-  SS << "]";
-  appendArgument(Name, SS.str());
-}
-
-// Append an IdentifierInfo argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name,
-                                        const clang::IdentifierInfo *Value) {
-  if (!Value) {
-    appendArgument(Name, "(null)");
-    return;
-  }
-  appendArgument(Name, Value->getName().str().c_str());
-}
-
-// Append a MacroDirective argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name,
-                                        const clang::MacroDirective *Value) {
-  if (!Value) {
-    appendArgument(Name, "(null)");
-    return;
-  }
-  appendArgument(Name, MacroDirectiveKindStrings[Value->getKind()]);
-}
-
-// Append a MacroDefinition argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name,
-                                        const clang::MacroDefinition &Value) {
-  std::string Str;
-  llvm::raw_string_ostream SS(Str);
-  SS << "[";
-  bool Any = false;
-  if (Value.getLocalDirective()) {
-    SS << "(local)";
-    Any = true;
-  }
-  for (auto *MM : Value.getModuleMacros()) {
-    if (Any) SS << ", ";
-    SS << MM->getOwningModule()->getFullModuleName();
-  }
-  SS << "]";
-  appendArgument(Name, SS.str());
-}
-
-// Append a MacroArgs argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name,
-                                        const clang::MacroArgs *Value) {
-  if (!Value) {
-    appendArgument(Name, "(null)");
-    return;
-  }
-  std::string Str;
-  llvm::raw_string_ostream SS(Str);
-  SS << "[";
-  // The argument tokens might include end tokens, so we reflect how
-  // how getUnexpArgument provides the arguments.
-  for (int I = 0, E = Value->getNumArguments(); I < E; ++I) {
-    const clang::Token *Current = Value->getUnexpArgument(I);
-    int TokenCount = Value->getArgLength(Current) + 1; // include EOF
-    E -= TokenCount;
-    if (I)
-      SS << ", ";
-    // We're assuming tokens are contiguous, as otherwise we have no
-    // other way to get at them.
-    --TokenCount;
-    for (int TokenIndex = 0; TokenIndex < TokenCount; ++TokenIndex, ++Current) {
-      if (TokenIndex)
-        SS << " ";
-      // We need to be careful here because the arguments might not be legal in
-      // YAML, so we use the token name for anything but identifiers and
-      // numeric literals.
-      if (Current->isAnyIdentifier() ||
-          Current->is(clang::tok::numeric_constant)) {
-        SS << PP.getSpelling(*Current);
-      } else {
-        SS << "<" << Current->getName() << ">";
-      }
-    }
-  }
-  SS << "]";
-  appendArgument(Name, SS.str());
-}
-
-// Append a Module argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name,
-                                        const clang::Module *Value) {
-  if (!Value) {
-    appendArgument(Name, "(null)");
-    return;
-  }
-  appendArgument(Name, Value->Name.c_str());
-}
-
-// Append a double-quoted argument to the top trace item.
-void PPCallbacksTracker::appendQuotedArgument(const char *Name,
-                                              const std::string &Value) {
-  std::string Str;
-  llvm::raw_string_ostream SS(Str);
-  SS << "\"" << Value << "\"";
-  appendArgument(Name, SS.str());
-}
-
-// Append a double-quoted file path argument to the top trace item.
-void PPCallbacksTracker::appendFilePathArgument(const char *Name,
-                                                llvm::StringRef Value) {
-  std::string Path(Value);
-  // YAML treats backslash as escape, so use forward slashes.
-  std::replace(Path.begin(), Path.end(), '\\', '/');
-  appendQuotedArgument(Name, Path);
-}
-
-// Get the raw source string of the range.
-llvm::StringRef
-PPCallbacksTracker::getSourceString(clang::CharSourceRange Range) {
-  const char *B = PP.getSourceManager().getCharacterData(Range.getBegin());
-  const char *E = PP.getSourceManager().getCharacterData(Range.getEnd());
-  return llvm::StringRef(B, E - B);
-}
+  Calls.beginCallback("MacroUndefined");
+  Calls.appendArgument("MacroNameTok", MacroNameTok, PP);
+  Calls.appendArgument("MacroDefinition", MacroDefinition);
+}
+
+// Hook called whenever the 'defined' operator is seen.
+void PPCallbacksTracker::Defined(const clang::Token &MacroNameTok,
+                                 const clang::MacroDefinition &MacroDefinition,
+                                 clang::SourceRange Range) {
+  Calls.beginCallback("Defined");
+  Calls.appendArgument("MacroNameTok", MacroNameTok, PP);
+  Calls.appendArgument("MacroDefinition", MacroDefinition);
+  Calls.appendArgument("Range", Range, PP);
+}
+
+// Hook called when a source range is skipped.
+void PPCallbacksTracker::SourceRangeSkipped(clang::SourceRange Range) {
+  Calls.beginCallback("SourceRangeSkipped");
+  Calls.appendArgument("Range", Range, PP);
+}
+
+// Hook called whenever an #if is seen.
+void PPCallbacksTracker::If(clang::SourceLocation Loc,
+                            clang::SourceRange ConditionRange,
+                            ConditionValueKind ConditionValue) {
+  Calls.beginCallback("If");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("ConditionRange", ConditionRange, PP);
+  Calls.appendArgument("ConditionValue", ConditionValue, ConditionValueKindStrings);
+}
+
+// Hook called whenever an #elif is seen.
+void PPCallbacksTracker::Elif(clang::SourceLocation Loc,
+                              clang::SourceRange ConditionRange,
+                              ConditionValueKind ConditionValue,
+                              clang::SourceLocation IfLoc) {
+  Calls.beginCallback("Elif");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("ConditionRange", ConditionRange, PP);
+  Calls.appendArgument("ConditionValue", ConditionValue, ConditionValueKindStrings);
+  Calls.appendArgument("IfLoc", IfLoc, PP);
+}
+
+// Hook called whenever an #ifdef is seen.
+void PPCallbacksTracker::Ifdef(clang::SourceLocation Loc,
+                               const clang::Token &MacroNameTok,
+                               const clang::MacroDefinition &MacroDefinition) {
+  Calls.beginCallback("Ifdef");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("MacroNameTok", MacroNameTok, PP);
+  Calls.appendArgument("MacroDefinition", MacroDefinition);
+}
+
+// Hook called whenever an #ifndef is seen.
+void PPCallbacksTracker::Ifndef(clang::SourceLocation Loc,
+                                const clang::Token &MacroNameTok,
+                                const clang::MacroDefinition &MacroDefinition) {
+  Calls.beginCallback("Ifndef");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("MacroNameTok", MacroNameTok, PP);
+  Calls.appendArgument("MacroDefinition", MacroDefinition);
+}
+
+// Hook called whenever an #else is seen.
+void PPCallbacksTracker::Else(clang::SourceLocation Loc,
+                              clang::SourceLocation IfLoc) {
+  Calls.beginCallback("Else");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("IfLoc", IfLoc, PP);
+}
+
+// Hook called whenever an #endif is seen.
+void PPCallbacksTracker::Endif(clang::SourceLocation Loc,
+                               clang::SourceLocation IfLoc) {
+  Calls.beginCallback("Endif");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("IfLoc", IfLoc, PP);
+}
+
+void PPCallbacksTracker::RecursiveExpansion(const clang::Token & Tok)
+{
+	auto B = getCharacterData(PP, Tok.getLocation());
+	auto tok = llvm::StringRef(B, Tok.getLength());
+	Calls.beginCallback("RecursiveExpansion");
+	Calls.appendArgument("MacroNameTok", tok);
+}
+
+// Helper functions.
\ No newline at end of file
Index: pp-trace/PPCallbacksTracker.h
===================================================================
--- pp-trace/PPCallbacksTracker.h	(revision 302379)
+++ pp-trace/PPCallbacksTracker.h	(working copy)
@@ -1,247 +1,156 @@
-//===--- PPCallbacksTracker.h - Preprocessor tracking -----------*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-///
-/// \file
-/// \brief Classes and definitions for preprocessor tracking.
-///
-/// The core definition is the PPCallbacksTracker class, derived from Clang's
-/// PPCallbacks class from the Lex library, which overrides all the callbacks
-/// and collects information about each callback call, saving it in a
-/// data structure built up of CallbackCall and Argument objects, which
-/// record the preprocessor callback name and arguments in high-level string
-/// form for later inspection.
-///
-//===----------------------------------------------------------------------===//
-
-#ifndef PPTRACE_PPCALLBACKSTRACKER_H
-#define PPTRACE_PPCALLBACKSTRACKER_H
-
-#include "clang/Lex/PPCallbacks.h"
-#include "clang/Lex/Preprocessor.h"
-#include "clang/Basic/SourceManager.h"
-#include "llvm/ADT/ArrayRef.h"
-#include "llvm/ADT/SmallSet.h"
-#include "llvm/ADT/StringRef.h"
-#include <string>
-#include <vector>
-
-/// \brief This class represents one callback function argument by name
-///   and value.
-class Argument {
-public:
-  Argument(llvm::StringRef Name, llvm::StringRef Value)
-      : Name(Name), Value(Value) {}
-  Argument() = default;
-
-  std::string Name;
-  std::string Value;
-};
-
-/// \brief This class represents one callback call by name and an array
-///   of arguments.
-class CallbackCall {
-public:
-  CallbackCall(llvm::StringRef Name) : Name(Name) {}
-  CallbackCall() = default;
-
-  std::string Name;
-  std::vector<Argument> Arguments;
-};
-
-/// \brief This class overrides the PPCallbacks class for tracking preprocessor
-///   activity by means of its callback functions.
-///
-/// This object is given a vector for storing the trace information, built up
-/// of CallbackCall and subordinate Argument objects for representing the
-/// callback calls and their arguments.  It's a reference so the vector can
-/// exist beyond the lifetime of this object, because it's deleted by the
-/// preprocessor automatically in its destructor.
-///
-/// This class supports a mechanism for inhibiting trace output for
-/// specific callbacks by name, for the purpose of eliminating output for
-/// callbacks of no interest that might clutter the output.
-///
-/// Following the constructor and destructor function declarations, the
-/// overidden callback functions are defined.  The remaining functions are
-/// helpers for recording the trace data, to reduce the coupling between it
-/// and the recorded data structure.
-class PPCallbacksTracker : public clang::PPCallbacks {
-public:
-  /// \brief Note that all of the arguments are references, and owned
-  /// by the caller.
-  /// \param Ignore - Set of names of callbacks to ignore.
-  /// \param CallbackCalls - Trace buffer.
-  /// \param PP - The preprocessor.  Needed for getting some argument strings.
-  PPCallbacksTracker(llvm::SmallSet<std::string, 4> &Ignore,
-                     std::vector<CallbackCall> &CallbackCalls,
-                     clang::Preprocessor &PP);
-
-  ~PPCallbacksTracker() override;
-
-  // Overidden callback functions.
-
-  void FileChanged(clang::SourceLocation Loc,
-                   clang::PPCallbacks::FileChangeReason Reason,
-                   clang::SrcMgr::CharacteristicKind FileType,
-                   clang::FileID PrevFID = clang::FileID()) override;
-  void FileSkipped(const clang::FileEntry &SkippedFile,
-                   const clang::Token &FilenameTok,
-                   clang::SrcMgr::CharacteristicKind FileType) override;
-  bool FileNotFound(llvm::StringRef FileName,
-                    llvm::SmallVectorImpl<char> &RecoveryPath) override;
-  void InclusionDirective(clang::SourceLocation HashLoc,
-                          const clang::Token &IncludeTok,
-                          llvm::StringRef FileName, bool IsAngled,
-                          clang::CharSourceRange FilenameRange,
-                          const clang::FileEntry *File,
-                          llvm::StringRef SearchPath,
-                          llvm::StringRef RelativePath,
-                          const clang::Module *Imported) override;
-  void moduleImport(clang::SourceLocation ImportLoc, clang::ModuleIdPath Path,
-                    const clang::Module *Imported) override;
-  void EndOfMainFile() override;
-  void Ident(clang::SourceLocation Loc, llvm::StringRef str) override;
-  void PragmaDirective(clang::SourceLocation Loc,
-                       clang::PragmaIntroducerKind Introducer) override;
-  void PragmaComment(clang::SourceLocation Loc,
-                     const clang::IdentifierInfo *Kind,
-                     llvm::StringRef Str) override;
-  void PragmaDetectMismatch(clang::SourceLocation Loc, llvm::StringRef Name,
-                            llvm::StringRef Value) override;
-  void PragmaDebug(clang::SourceLocation Loc,
-                   llvm::StringRef DebugType) override;
-  void PragmaMessage(clang::SourceLocation Loc, llvm::StringRef Namespace,
-                     clang::PPCallbacks::PragmaMessageKind Kind,
-                     llvm::StringRef Str) override;
-  void PragmaDiagnosticPush(clang::SourceLocation Loc,
-                            llvm::StringRef Namespace) override;
-  void PragmaDiagnosticPop(clang::SourceLocation Loc,
-                           llvm::StringRef Namespace) override;
-  void PragmaDiagnostic(clang::SourceLocation Loc, llvm::StringRef Namespace,
-                        clang::diag::Severity mapping,
-                        llvm::StringRef Str) override;
-  void PragmaOpenCLExtension(clang::SourceLocation NameLoc,
-                             const clang::IdentifierInfo *Name,
-                             clang::SourceLocation StateLoc,
-                             unsigned State) override;
-  void PragmaWarning(clang::SourceLocation Loc, llvm::StringRef WarningSpec,
-                     llvm::ArrayRef<int> Ids) override;
-  void PragmaWarningPush(clang::SourceLocation Loc, int Level) override;
-  void PragmaWarningPop(clang::SourceLocation Loc) override;
-  void MacroExpands(const clang::Token &MacroNameTok,
-                    const clang::MacroDefinition &MD, clang::SourceRange Range,
-                    const clang::MacroArgs *Args) override;
-  void MacroDefined(const clang::Token &MacroNameTok,
-                    const clang::MacroDirective *MD) override;
-  void MacroUndefined(const clang::Token &MacroNameTok,
+//===--- PPCallbacksTracker.h - Preprocessor tracking -----------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+///
+/// \file
+/// \brief Classes and definitions for preprocessor tracking.
+///
+/// The core definition is the PPCallbacksTracker class, derived from Clang's
+/// PPCallbacks class from the Lex library, which overrides all the callbacks
+/// and collects information about each callback call, saving it in a
+/// data structure built up of CallbackCall and Argument objects, which
+/// record the preprocessor callback name and arguments in high-level string
+/// form for later inspection.
+///
+//===----------------------------------------------------------------------===//
+
+#ifndef PPTRACE_PPCALLBACKSTRACKER_H
+#define PPTRACE_PPCALLBACKSTRACKER_H
+
+#include "CallbackCall.h"
+#include "ArgTokens.h"
+#include "clang/Lex/PPCallbacks.h"
+#include "clang/Lex/Preprocessor.h"
+#include "clang/Basic/SourceManager.h"
+#include "llvm/ADT/ArrayRef.h"
+#include "llvm/ADT/SmallSet.h"
+#include "llvm/ADT/StringRef.h"
+#include "Utils.h"
+#include <string>
+#include <vector>
+
+/// \brief This class overrides the PPCallbacks class for tracking preprocessor
+///   activity by means of its callback functions.
+///
+/// This object is given a vector for storing the trace information, built up
+/// of CallbackCall and subordinate Argument objects for representing the
+/// callback calls and their arguments.  It's a reference so the vector can
+/// exist beyond the lifetime of this object, because it's deleted by the
+/// preprocessor automatically in its destructor.
+///
+/// This class supports a mechanism for inhibiting trace output for
+/// specific callbacks by name, for the purpose of eliminating output for
+/// callbacks of no interest that might clutter the output.
+///
+/// Following the constructor and destructor function declarations, the
+/// overidden callback functions are defined.  The remaining functions are
+/// helpers for recording the trace data, to reduce the coupling between it
+/// and the recorded data structure.
+class PPCallbacksTracker : public clang::PPCallbacks {
+public:
+  /// \brief Note that all of the arguments are references, and owned
+  /// by the caller.
+  /// \param Ignore - Set of names of callbacks to ignore.
+  /// \param CallbackCalls - Trace buffer.
+  /// \param PP - The preprocessor.  Needed for getting some argument strings.
+  PPCallbacksTracker(CallbackCalls &CallbackCalls,
+                     clang::Preprocessor &PP);
+
+  virtual ~PPCallbacksTracker() override;
+
+  // Overidden callback functions.
+
+  void FileChanged(clang::SourceLocation Loc,
+                   clang::PPCallbacks::FileChangeReason Reason,
+                   clang::SrcMgr::CharacteristicKind FileType,
+                   clang::FileID PrevFID = clang::FileID()) override;
+  void FileSkipped(const clang::FileEntry &SkippedFile,
+                   const clang::Token &FilenameTok,
+                   clang::SrcMgr::CharacteristicKind FileType) override;
+  bool FileNotFound(llvm::StringRef FileName,
+                    llvm::SmallVectorImpl<char> &RecoveryPath) override;
+  void InclusionDirective(clang::SourceLocation HashLoc,
+                          const clang::Token &IncludeTok,
+                          llvm::StringRef FileName, bool IsAngled,
+                          clang::CharSourceRange FilenameRange,
+                          const clang::FileEntry *File,
+                          llvm::StringRef SearchPath,
+                          llvm::StringRef RelativePath,
+                          const clang::Module *Imported) override;
+  void moduleImport(clang::SourceLocation ImportLoc, clang::ModuleIdPath Path,
+                    const clang::Module *Imported) override;
+  void EndOfMainFile() override;
+  void Ident(clang::SourceLocation Loc, llvm::StringRef str) override;
+  void PragmaDirective(clang::SourceLocation Loc,
+                       clang::PragmaIntroducerKind Introducer) override;
+  void PragmaComment(clang::SourceLocation Loc,
+                     const clang::IdentifierInfo *Kind,
+                     llvm::StringRef Str) override;
+  void PragmaDetectMismatch(clang::SourceLocation Loc, llvm::StringRef Name,
+                            llvm::StringRef Value) override;
+  void PragmaDebug(clang::SourceLocation Loc,
+                   llvm::StringRef DebugType) override;
+  void PragmaMessage(clang::SourceLocation Loc, llvm::StringRef Namespace,
+                     clang::PPCallbacks::PragmaMessageKind Kind,
+                     llvm::StringRef Str) override;
+  void PragmaDiagnosticPush(clang::SourceLocation Loc,
+                            llvm::StringRef Namespace) override;
+  void PragmaDiagnosticPop(clang::SourceLocation Loc,
+                           llvm::StringRef Namespace) override;
+  void PragmaDiagnostic(clang::SourceLocation Loc, llvm::StringRef Namespace,
+                        clang::diag::Severity mapping,
+                        llvm::StringRef Str) override;
+  void PragmaOpenCLExtension(clang::SourceLocation NameLoc,
+                             const clang::IdentifierInfo *Name,
+                             clang::SourceLocation StateLoc,
+                             unsigned State) override;
+  void PragmaWarning(clang::SourceLocation Loc, llvm::StringRef WarningSpec,
+                     llvm::ArrayRef<int> Ids) override;
+  void PragmaWarningPush(clang::SourceLocation Loc, int Level) override;
+  void PragmaWarningPop(clang::SourceLocation Loc) override;
+  virtual void MacroExpands(const clang::Token &MacroNameTok,
+                    const clang::MacroDefinition &MD, clang::SourceRange Range,
+                    const clang::MacroArgs *Args) override;
+  void MacroDefined(const clang::Token &MacroNameTok,
+                    const clang::MacroDirective *MD) override;
+  void MacroUndefined(const clang::Token &MacroNameTok,
                       const clang::MacroDefinition &MD,
                       const clang::MacroDirective *Undef) override;
-  void Defined(const clang::Token &MacroNameTok,
-               const clang::MacroDefinition &MD,
-               clang::SourceRange Range) override;
-  void SourceRangeSkipped(clang::SourceRange Range) override;
-  void If(clang::SourceLocation Loc, clang::SourceRange ConditionRange,
-          ConditionValueKind ConditionValue) override;
-  void Elif(clang::SourceLocation Loc, clang::SourceRange ConditionRange,
-            ConditionValueKind ConditionValue, clang::SourceLocation IfLoc) override;
-  void Ifdef(clang::SourceLocation Loc, const clang::Token &MacroNameTok,
-             const clang::MacroDefinition &MD) override;
-  void Ifndef(clang::SourceLocation Loc, const clang::Token &MacroNameTok,
-              const clang::MacroDefinition &MD) override;
-  void Else(clang::SourceLocation Loc,
-            clang::SourceLocation IfLoc) override;
-  void Endif(clang::SourceLocation Loc,
-             clang::SourceLocation IfLoc) override;
-
-  // Helper functions.
-
-  /// \brief Start a new callback.
-  void beginCallback(const char *Name);
-
-  /// \brief Append a string to the top trace item.
-  void append(const char *Str);
-
-  /// \brief Append a bool argument to the top trace item.
-  void appendArgument(const char *Name, bool Value);
-
-  /// \brief Append an int argument to the top trace item.
-  void appendArgument(const char *Name, int Value);
-
-  /// \brief Append a string argument to the top trace item.
-  void appendArgument(const char *Name, const char *Value);
-
-  /// \brief Append a string reference object argument to the top trace item.
-  void appendArgument(const char *Name, llvm::StringRef Value);
-
-  /// \brief Append a string object argument to the top trace item.
-  void appendArgument(const char *Name, const std::string &Value);
-
-  /// \brief Append a token argument to the top trace item.
-  void appendArgument(const char *Name, const clang::Token &Value);
-
-  /// \brief Append an enum argument to the top trace item.
-  void appendArgument(const char *Name, int Value, const char *const Strings[]);
-
-  /// \brief Append a FileID argument to the top trace item.
-  void appendArgument(const char *Name, clang::FileID Value);
-
-  /// \brief Append a FileEntry argument to the top trace item.
-  void appendArgument(const char *Name, const clang::FileEntry *Value);
-
-  /// \brief Append a SourceLocation argument to the top trace item.
-  void appendArgument(const char *Name, clang::SourceLocation Value);
-
-  /// \brief Append a SourceRange argument to the top trace item.
-  void appendArgument(const char *Name, clang::SourceRange Value);
-
-  /// \brief Append a CharSourceRange argument to the top trace item.
-  void appendArgument(const char *Name, clang::CharSourceRange Value);
-
-  /// \brief Append a ModuleIdPath argument to the top trace item.
-  void appendArgument(const char *Name, clang::ModuleIdPath Value);
-
-  /// \brief Append an IdentifierInfo argument to the top trace item.
-  void appendArgument(const char *Name, const clang::IdentifierInfo *Value);
-
-  /// \brief Append a MacroDirective argument to the top trace item.
-  void appendArgument(const char *Name, const clang::MacroDirective *Value);
-
-  /// \brief Append a MacroDefinition argument to the top trace item.
-  void appendArgument(const char *Name, const clang::MacroDefinition &Value);
-
-  /// \brief Append a MacroArgs argument to the top trace item.
-  void appendArgument(const char *Name, const clang::MacroArgs *Value);
-
-  /// \brief Append a Module argument to the top trace item.
-  void appendArgument(const char *Name, const clang::Module *Value);
-
-  /// \brief Append a double-quoted argument to the top trace item.
-  void appendQuotedArgument(const char *Name, const std::string &Value);
-
-  /// \brief Append a double-quoted file path argument to the top trace item.
-  void appendFilePathArgument(const char *Name, llvm::StringRef Value);
-
-  /// \brief Get the raw source string of the range.
-  llvm::StringRef getSourceString(clang::CharSourceRange Range);
-
-  /// \brief Callback trace information.
-  /// We use a reference so the trace will be preserved for the caller
-  /// after this object is destructed.
-  std::vector<CallbackCall> &CallbackCalls;
-
-  /// \brief Names of callbacks to ignore.
-  llvm::SmallSet<std::string, 4> &Ignore;
-
-  /// \brief Inhibit trace while this is set.
-  bool DisableTrace;
-
-  clang::Preprocessor &PP;
-};
-
-#endif // PPTRACE_PPCALLBACKSTRACKER_H
+  void Defined(const clang::Token &MacroNameTok,
+               const clang::MacroDefinition &MD,
+               clang::SourceRange Range) override;
+  void SourceRangeSkipped(clang::SourceRange Range) override;
+  void If(clang::SourceLocation Loc, clang::SourceRange ConditionRange,
+          ConditionValueKind ConditionValue) override;
+  void Elif(clang::SourceLocation Loc, clang::SourceRange ConditionRange,
+            ConditionValueKind ConditionValue, clang::SourceLocation IfLoc) override;
+  void Ifdef(clang::SourceLocation Loc, const clang::Token &MacroNameTok,
+             const clang::MacroDefinition &MD) override;
+  void Ifndef(clang::SourceLocation Loc, const clang::Token &MacroNameTok,
+              const clang::MacroDefinition &MD) override;
+  void Else(clang::SourceLocation Loc,
+            clang::SourceLocation IfLoc) override;
+  void Endif(clang::SourceLocation Loc,
+             clang::SourceLocation IfLoc) override;
+  void RecursiveExpansion(const clang::Token& Tok) override;
+
+  // Helper functions.
+
+protected:
+
+  /// \brief Template method for 
+  virtual bool BuildCache() { return true; }
+protected:
+
+  clang::Preprocessor &PP;
+  CallbackCalls &Calls;
+  ArgTokens CurrArgs;
+};
+
+
+#endif // PPTRACE_PPCALLBACKSTRACKER_H
Index: pp-trace/PPCallbacksVerbose.cpp
===================================================================
--- pp-trace/PPCallbacksVerbose.cpp	(nonexistent)
+++ pp-trace/PPCallbacksVerbose.cpp	(working copy)
@@ -0,0 +1,51 @@
+#include "PPCallbacksVerbose.h"
+#include <numeric>
+
+using namespace llvm;
+using namespace clang;
+
+PPCallbacksVerbose::PPCallbacksVerbose(CallbackCalls& CallbackCalls,
+	                                   clang::Preprocessor & PP)
+	: PPCallbacksTracker(CallbackCalls, PP)
+{
+}
+
+PPCallbacksVerbose::~PPCallbacksVerbose() {}
+
+void PPCallbacksVerbose::MacroExpands(const clang::Token &MacroNameTok,
+	const clang::MacroDefinition &MD, clang::SourceRange Range,
+	const clang::MacroArgs *Args) {
+	PPCallbacksTracker::MacroExpands(MacroNameTok, MD, Range, Args);
+
+	const auto DefBody = MD.getMacroInfo()->tokens();
+  auto RawDefBody = std::vector<std::string>(DefBody.size());
+
+	for (const auto& t : DefBody) {
+    auto B = getCharacterData(PP, t.getLocation());
+    const auto tok = StringRef(B, t.getLength());
+    RawDefBody.push_back(tok);
+	}
+
+  for (const auto &CurrArg : CurrArgs) {
+    for (auto &BodyToken : RawDefBody) {
+      if (std::get<0>(CurrArg).compare(BodyToken) == 0) {
+        const auto& ArgTokens = std::get<1>(CurrArg);
+        BodyToken =
+          std::accumulate(ArgTokens.begin(), ArgTokens.end(), std::string(""));
+      }
+    }
+  }
+
+	Calls.appendArgument("ExpandedTokens",
+    std::accumulate(RawDefBody.begin(),RawDefBody.end(), std::string("")));
+}
+
+void PPCallbacksVerbose::MacroDefined(const clang::Token &MacroNameTok,
+	const clang::MacroDirective *MD) {
+	PPCallbacksTracker::MacroDefined(MacroNameTok, MD);
+
+	const auto likeness = MD->getDefinition().getMacroInfo()->isObjectLike();
+	Calls.appendArgument("Likeness",
+		likeness ? "Object" : "Function");
+	Calls.appendArgument("Loc", MD->getLocation(), PP);
+}
Index: pp-trace/PPCallbacksVerbose.h
===================================================================
--- pp-trace/PPCallbacksVerbose.h	(nonexistent)
+++ pp-trace/PPCallbacksVerbose.h	(working copy)
@@ -0,0 +1,19 @@
+#include "PPCallbacksTracker.h"
+
+class PPCallbacksVerbose : public PPCallbacksTracker {
+public:
+	PPCallbacksVerbose(CallbackCalls& CallbackCalls,
+		clang::Preprocessor &PP);
+
+	virtual ~PPCallbacksVerbose() override;
+
+	void MacroExpands(const clang::Token &MacroNameTok,
+		const clang::MacroDefinition &MD, clang::SourceRange Range,
+		const clang::MacroArgs *Args) override;
+	void MacroDefined(const clang::Token &MacroNameTok,
+		const clang::MacroDirective *MD) override;
+
+protected:
+  virtual bool BuildCache() override { return true; }
+
+};
\ No newline at end of file
Index: pp-trace/PPTrace.cpp
===================================================================
--- pp-trace/PPTrace.cpp	(revision 302379)
+++ pp-trace/PPTrace.cpp	(working copy)
@@ -46,7 +46,9 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "Utils.h"
 #include "PPCallbacksTracker.h"
+#include "PPCallbacksVerbose.h"
 #include "clang/AST/ASTConsumer.h"
 #include "clang/AST/ASTContext.h"
 #include "clang/AST/RecursiveASTVisitor.h"
@@ -86,6 +88,11 @@
                                          cl::desc("<source0> [... <sourceN>]"),
                                          cl::OneOrMore);
 
+// Option to switch on verbose mode.
+static cl::opt<bool> VerboseMode(
+	"verbose", cl::init(false),
+	cl::desc("Print more information."));
+
 // Option to specify a list or one or more callback names to ignore.
 static cl::opt<std::string> IgnoreCallbacks(
     "ignore", cl::init(""),
@@ -105,75 +112,47 @@
 
 namespace {
 // Consumer is responsible for setting up the callbacks.
+template <typename Tracker>
 class PPTraceConsumer : public ASTConsumer {
 public:
-  PPTraceConsumer(SmallSet<std::string, 4> &Ignore,
-                  std::vector<CallbackCall> &CallbackCalls, Preprocessor &PP) {
+  PPTraceConsumer(CallbackCalls &CallbackCalls, Preprocessor &PP) {
     // PP takes ownership.
-    PP.addPPCallbacks(llvm::make_unique<PPCallbacksTracker>(Ignore,
-                                                            CallbackCalls, PP));
+    PP.addPPCallbacks(llvm::make_unique<Tracker>(CallbackCalls, PP));
   }
 };
 
+template <typename Tracker>
 class PPTraceAction : public SyntaxOnlyAction {
 public:
-  PPTraceAction(SmallSet<std::string, 4> &Ignore,
-                std::vector<CallbackCall> &CallbackCalls)
-      : Ignore(Ignore), CallbackCalls(CallbackCalls) {}
+  PPTraceAction(CallbackCalls &CallbackCalls)
+      : CallbackCalls(CallbackCalls) {}
 
 protected:
   std::unique_ptr<clang::ASTConsumer>
   CreateASTConsumer(CompilerInstance &CI, StringRef InFile) override {
-    return llvm::make_unique<PPTraceConsumer>(Ignore, CallbackCalls,
+    return llvm::make_unique<PPTraceConsumer<Tracker>>(CallbackCalls,
                                               CI.getPreprocessor());
   }
 
 private:
-  SmallSet<std::string, 4> &Ignore;
-  std::vector<CallbackCall> &CallbackCalls;
+  CallbackCalls &CallbackCalls;
 };
 
+template <typename Tracker>
 class PPTraceFrontendActionFactory : public FrontendActionFactory {
 public:
-  PPTraceFrontendActionFactory(SmallSet<std::string, 4> &Ignore,
-                               std::vector<CallbackCall> &CallbackCalls)
-      : Ignore(Ignore), CallbackCalls(CallbackCalls) {}
+  PPTraceFrontendActionFactory(CallbackCalls &CallbackCalls)
+      : CallbackCalls(CallbackCalls) {}
 
-  PPTraceAction *create() override {
-    return new PPTraceAction(Ignore, CallbackCalls);
+  PPTraceAction<Tracker> *create() override {
+    return new PPTraceAction<Tracker>(CallbackCalls);
   }
 
 private:
-  SmallSet<std::string, 4> &Ignore;
-  std::vector<CallbackCall> &CallbackCalls;
+  CallbackCalls &CallbackCalls;
 };
 } // namespace
 
-// Output the trace given its data structure and a stream.
-static int outputPPTrace(std::vector<CallbackCall> &CallbackCalls,
-                         llvm::raw_ostream &OS) {
-  // Mark start of document.
-  OS << "---\n";
-
-  for (std::vector<CallbackCall>::const_iterator I = CallbackCalls.begin(),
-                                                 E = CallbackCalls.end();
-       I != E; ++I) {
-    const CallbackCall &Callback = *I;
-    OS << "- Callback: " << Callback.Name << "\n";
-
-    for (auto AI = Callback.Arguments.begin(), AE = Callback.Arguments.end();
-         AI != AE; ++AI) {
-      const Argument &Arg = *AI;
-      OS << "  " << Arg.Name << ": " << Arg.Value << "\n";
-    }
-  }
-
-  // Mark end of document.
-  OS << "...\n";
-
-  return 0;
-}
-
 // Program entry point.
 int main(int Argc, const char **Argv) {
 
@@ -185,10 +164,8 @@
   StringRef(IgnoreCallbacks).split(IgnoreCallbacksStrings, ",",
                                    /*MaxSplit=*/ -1, /*KeepEmpty=*/false);
   SmallSet<std::string, 4> Ignore;
-  for (SmallVector<StringRef, 32>::iterator I = IgnoreCallbacksStrings.begin(),
-                                            E = IgnoreCallbacksStrings.end();
-       I != E; ++I)
-    Ignore.insert(*I);
+  for (auto& CallbackStr : IgnoreCallbacksStrings)
+    Ignore.insert(CallbackStr);
 
   // Create the compilation database.
   SmallString<256> PathBuf;
@@ -197,14 +174,21 @@
   Compilations.reset(
       new FixedCompilationDatabase(Twine(PathBuf), CC1Arguments));
 
-  // Store the callback trace information here.
-  std::vector<CallbackCall> CallbackCalls;
-
   // Create the tool and run the compilation.
   ClangTool Tool(*Compilations, SourcePaths);
-  PPTraceFrontendActionFactory Factory(Ignore, CallbackCalls);
-  int HadErrors = Tool.run(&Factory);
 
+  CallbackCalls Calls = VerboseMode ? CallbackCallsVerbose(Ignore) : CallbackCalls(Ignore);
+
+  int HadErrors = 0;
+  if (VerboseMode) {
+	  PPTraceFrontendActionFactory<PPCallbacksVerbose> Factory(Calls);
+	  HadErrors = Tool.run(&Factory);
+  }
+  else {
+	  PPTraceFrontendActionFactory<PPCallbacksTracker> Factory(Calls);
+	  HadErrors = Tool.run(&Factory);
+  }
+
   // If we had errors, exit early.
   if (HadErrors)
     return HadErrors;
@@ -211,7 +195,7 @@
 
   // Do the output.
   if (!OutputFileName.size()) {
-    HadErrors = outputPPTrace(CallbackCalls, llvm::outs());
+    HadErrors = outputPPTrace(Calls, llvm::outs());
   } else {
     // Set up output file.
     std::error_code EC;
@@ -222,7 +206,7 @@
       return 1;
     }
 
-    HadErrors = outputPPTrace(CallbackCalls, Out.os());
+    HadErrors = outputPPTrace(Calls, Out.os());
 
     // Tell tool_output_file that we want to keep the file.
     if (HadErrors == 0)
Index: pp-trace/Utils.h
===================================================================
--- pp-trace/Utils.h	(nonexistent)
+++ pp-trace/Utils.h	(working copy)
@@ -0,0 +1,81 @@
+#ifndef PPTRACE_UTILS_H
+#define PPTRACE_UTILS_H
+
+#include "CallbackCall.h"
+#include "PPCallbacksTracker.h"
+#include "clang/Lex/Preprocessor.h"
+#include "clang/Lex/MacroArgs.h"
+#include "clang/Basic/SourceManager.h"
+#include <string>
+#include <vector>
+
+// Utility functions.
+
+// Get a "file:line:column" source location string.
+inline auto getSourceLocationString(const clang::Preprocessor& PP,
+	clang::SourceLocation Loc) {
+	if (Loc.isInvalid())
+		return std::string("(none)");
+
+	if (Loc.isFileID()) {
+		const auto PLoc = PP.getSourceManager().getPresumedLoc(Loc);
+
+		if (PLoc.isInvalid()) {
+			return std::string("(invalid)");
+		}
+
+		std::string Str;
+		llvm::raw_string_ostream SS(Str);
+
+		// The macro expansion and spelling pos is identical for file locs.
+		SS << "\"" << PLoc.getFilename() << ':' << PLoc.getLine() << ':'
+			<< PLoc.getColumn() << "\"";
+
+		auto Result = SS.str();
+
+		// YAML treats backslash as escape, so use forward slashes.
+		std::replace(Result.begin(), Result.end(), '\\', '/');
+
+		return Result;
+	}
+
+	return std::string("(nonfile)");
+}
+
+inline auto getCharacterData(const clang::Preprocessor &PP, const clang::SourceLocation& Loc) {
+	return PP.getSourceManager().getCharacterData(Loc);
+}
+
+// Get the raw source string of the range.
+template <typename T>
+inline auto getSourceString(const clang::Preprocessor &PP, const T& Range) {
+	const auto B = getCharacterData(PP, Range.getBegin());
+	const auto E = getCharacterData(PP, Range.getEnd());
+	return llvm::StringRef(B, E - B + 1).trim();
+}
+
+// Output the trace given its data structure and a stream.
+inline auto outputPPTrace(CallbackCalls &CallbackCalls,
+	llvm::raw_ostream &OS) {
+	// Mark start of document.
+	OS << "---\n";
+
+	for (const auto& Callback : CallbackCalls) {
+		OS << "- Callback: " << Callback.Name << "\n";
+
+		for (const auto& Arg : Callback.Arguments) {
+			OS << "  " << Arg.Name << ": " << Arg.Value << "\n";
+		}
+	}
+
+	// Mark end of document.
+	OS << "...\n";
+
+	return 0;
+}
+
+inline auto extractMacroArgTokens(const clang::MacroArgs* Args, clang::Preprocessor& PP) {
+
+}
+
+#endif // PPTRACE_UTILS_H
Index: test/pp-trace/pp-trace-macro.cpp
===================================================================
--- test/pp-trace/pp-trace-macro.cpp	(revision 302379)
+++ test/pp-trace/pp-trace-macro.cpp	(working copy)
@@ -37,7 +37,6 @@
 // CHECK-NEXT:   MacroNameTok: MACRO
 // CHECK-NEXT:   MacroDefinition: [(local)]
 // CHECK-NEXT:   Range: ["{{.*}}{{[/\\]}}pp-trace-macro.cpp:4:9", "{{.*}}{{[/\\]}}pp-trace-macro.cpp:4:9"]
-// CHECK-NEXT:   Args: (null)
 // CHECK-NEXT: - Callback: Defined
 // CHECK-NEXT:   MacroNameTok: MACRO
 // CHECK-NEXT:   MacroDefinition: [(local)]
@@ -72,7 +71,8 @@
 // CHECK-NEXT:   MacroNameTok: FUNCMACRO
 // CHECK-NEXT:   MacroDefinition: [(local)]
 // CHECK-NEXT:   Range: ["{{.*}}{{[/\\]}}pp-trace-macro.cpp:11:9", "{{.*}}{{[/\\]}}pp-trace-macro.cpp:11:20"]
-// CHECK-NEXT:   Args: [1]
+// CHECK-NEXT:   Args:
+// CHECK-NEXT:   - ARG1: 1
 // CHECK-NEXT: - Callback: MacroDefined
 // CHECK-NEXT:   MacroNameTok: X
 // CHECK-NEXT:   MacroDirective: MD_Define
@@ -85,17 +85,23 @@
 // CHECK-NEXT: - Callback: MacroExpands
 // CHECK-NEXT:   MacroNameTok: X
 // CHECK-NEXT:   MacroDefinition: [(local)]
-// CHECK-NEXT:   Range: ["{{.*}}{{[/\\]}}pp-trace-macro.cpp:15:1", "{{.*}}{{[/\\]}}pp-trace-macro.cpp:15:1"]
-// CHECK-NEXT:   Args: (null)
+// CHECK-NEXT:   Range: ["{{.*}}{{[/\\]}}pp-trace-macro.cpp:15:1", "{{.*}}{{[/\\]}}pp-trace-macro.cpp:15:1"]
+// CHECK-NEXT: - Callback: RecursiveExpansion
+// CHECK-NEXT:   MacroNameTok: X_IMPL
 // CHECK-NEXT: - Callback: MacroExpands
 // CHECK-NEXT:   MacroNameTok: X_IMPL
 // CHECK-NEXT:   MacroDefinition: [(local)]
 // CHECK-NEXT:   Range: [(nonfile), (nonfile)]
-// CHECK-NEXT:   Args: [a <plus> y, b]
+// CHECK-NEXT:   Args:
+// CHECK-NEXT:   - p1: a+y
+// CHECK-NEXT:   - p2: b
+// CHECK-NEXT: - Callback: RecursiveExpansion
+// CHECK-NEXT:   MacroNameTok: X_IMPL2
 // CHECK-NEXT: - Callback: MacroExpands
 // CHECK-NEXT:   MacroNameTok: X_IMPL2
 // CHECK-NEXT:   MacroDefinition: [(local)]
 // CHECK-NEXT:   Range: [(nonfile), (nonfile)]
-// CHECK-NEXT:   Args: [c]
+// CHECK-NEXT:   Args:
+// CHECK-NEXT:   - p1: c
 // CHECK-NEXT: - Callback: EndOfMainFile
 // CHECK-NEXT: ...
Index: test/pp-trace/pp-trace-verbose.cpp
===================================================================
--- test/pp-trace/pp-trace-verbose.cpp	(nonexistent)
+++ test/pp-trace/pp-trace-verbose.cpp	(working copy)
@@ -0,0 +1,163 @@
+// RUN: pp-trace -verbose -ignore FileChanged %s -undef -target x86_64 -std=c++11 | FileCheck --strict-whitespace %s
+
+#define ZERO 0
+#define TWO 2
+#define ARG(a) a
+#define ARGS(...) __VA_ARGS__
+#define MUL(LHS, RHS) ((LHS) * (RHS))
+#define SQ(a) (MUL(a, a))
+#define ARGS2(a, ...) a + ARGS(__VA_ARGS__)
+
+int main() {
+    return ARGS(MUL(ZERO, SQ(TWO - ZERO))) + ARGS2(2, 3, 4, 5, 6);
+}
+
+// CHECK: ---
+// CHECK-NEXT: - Callback: MacroDefined
+// CHECK:        MacroNameTok: __STDC__
+// CHECK-NEXT:   MacroDirective: MD_Define
+// CHECK-NEXT:   Likeness: Object
+// CHECK-NEXT:   Loc: "<built-in>:{{[0-9+]}}:{{[0-9+]}}"
+// CHECK-NEXT: - Callback: MacroDefined
+// CHECK:        MacroNameTok: __STDC_HOSTED__
+// CHECK-NEXT:   MacroDirective: MD_Define
+// CHECK-NEXT:   Likeness: Object
+// CHECK-NEXT:   Loc: "<built-in>:{{[0-9+]}}:{{[0-9+]}}"
+// CHECK-NEXT: - Callback: MacroDefined
+// CHECK-NEXT:   MacroNameTok: __cplusplus
+// CHECK-NEXT:   MacroDirective: MD_Define
+// CHECK-NEXT:   Likeness: Object
+// CHECK-NEXT:   Loc: "<built-in>:{{[0-9+]}}:{{[0-9+]}}"
+// CHECK-NEXT: - Callback: MacroDefined
+// CHECK:        MacroNameTok: __STDC_UTF_16__
+// CHECK-NEXT:   MacroDirective: MD_Define
+// CHECK-NEXT:   Likeness: Object
+// CHECK-NEXT:   "<built-in>:{{[0-9+]}}:{{[0-9+]}}"
+// CHECK-NEXT: - Callback: MacroDefined
+// CHECK:        MacroNameTok: __STDC_UTF_32__
+// CHECK-NEXT:   MacroDirective: MD_Define
+// CHECK-NEXT:   Likeness: Object
+// CHECK-NEXT:   "<built-in>:{{[0-9+]}}:{{[0-9+]}}"
+// CHECK-NEXT: - Callback: MacroDefined
+// CHECK-NEXT:   MacroNameTok: ZERO
+// CHECK-NEXT:   MacroDirective: MD_Define
+// CHECK-NEXT:   Likeness: Object
+// CHECK-NEXT:   Loc: "{{.*}}{{[/\\]}}pp-trace-verbose.cpp:3:9"
+// CHECK-NEXT: - Callback: MacroDefined
+// CHECK-NEXT:   MacroNameTok: TWO
+// CHECK-NEXT:   MacroDirective: MD_Define
+// CHECK-NEXT:   Likeness: Object
+// CHECK-NEXT:   Loc: "{{.*}}{{[/\\]}}pp-trace-verbose.cpp:4:9"
+// CHECK-NEXT: - Callback: MacroDefined
+// CHECK-NEXT:   MacroNameTok: ARG
+// CHECK-NEXT:   MacroDirective: MD_Define
+// CHECK-NEXT:   Likeness: Function
+// CHECK-NEXT:   Loc: "{{.*}}{{[/\\]}}pp-trace-verbose.cpp:5:9"
+// CHECK-NEXT: - Callback: MacroDefined
+// CHECK-NEXT:   MacroNameTok: ARGS
+// CHECK-NEXT:   MacroDirective: MD_Define
+// CHECK-NEXT:   Likeness: Function
+// CHECK-NEXT:   Loc: "{{.*}}{{[/\\]}}pp-trace-verbose.cpp:6:9"
+// CHECK-NEXT: - Callback: MacroDefined
+// CHECK-NEXT:   MacroNameTok: MUL
+// CHECK-NEXT:   MacroDirective: MD_Define
+// CHECK-NEXT:   Likeness: Function
+// CHECK-NEXT:   Loc: "{{.*}}{{[/\\]}}pp-trace-verbose.cpp:7:9"
+// CHECK-NEXT: - Callback: MacroDefined
+// CHECK-NEXT:   MacroNameTok: SQ
+// CHECK-NEXT:   MacroDirective: MD_Define
+// CHECK-NEXT:   Likeness: Function
+// CHECK-NEXT:   Loc: "{{.*}}{{[/\\]}}pp-trace-verbose.cpp:8:9"
+// CHECK-NEXT: - Callback: MacroDefined
+// CHECK-NEXT:   MacroNameTok: ARGS2
+// CHECK-NEXT:   MacroDirective: MD_Define
+// CHECK-NEXT:   Likeness: Function
+// CHECK-NEXT:   Loc: "{{.*}}{{[/\\]}}pp-trace-verbose.cpp:9:9"
+// CHECK-NEXT: - Callback: MacroExpands
+// CHECK-NEXT:   MacroNameTok: ARGS
+// CHECK-NEXT:   MacroDefinition: [(local)]
+// CHECK-NEXT:   Range: ["{{.*}}{{[/\\]}}pp-trace-verbose.cpp:12:12", "{{.*}}{{[/\\]}}pp-trace-verbose.cpp:12:42"]
+// CHECK-NEXT:   Args:
+// CHECK-NEXT:   - __VA_ARGS__: MUL(ZERO,SQ(TWO-ZERO))
+// CHECK-NEXT:   ExpandedTokens: MUL(ZERO,SQ(TWO-ZERO))
+// CHECK-NEXT: - Callback: RecursiveExpansion
+// CHECK-NEXT:   MacroNameTok: MUL
+// CHECK-NEXT: - Callback: RecursiveExpansion
+// CHECK-NEXT:   MacroNameTok: ZERO
+// CHECK-NEXT: - Callback: RecursiveExpansion
+// CHECK-NEXT:   MacroNameTok: SQ
+// CHECK-NEXT: - Callback: RecursiveExpansion
+// CHECK-NEXT:   MacroNameTok: TWO
+// CHECK-NEXT: - Callback: RecursiveExpansion
+// CHECK-NEXT:   MacroNameTok: ZERO
+// CHECK-NEXT: - Callback: MacroExpands
+// CHECK-NEXT:   MacroNameTok: MUL
+// CHECK-NEXT:   MacroDefinition: [(local)]
+// CHECK-NEXT:   Range: ["{{.*}}{{[/\\]}}pp-trace-verbose.cpp:12:17", "{{.*}}{{[/\\]}}pp-trace-verbose.cpp:12:41"]
+// CHECK-NEXT:   Args:
+// CHECK-NEXT:   - LHS: ZERO
+// CHECK-NEXT:   - RHS: SQ(TWO-ZERO)
+// CHECK-NEXT:   ExpandedTokens: ((ZERO)*(SQ(TWO-ZERO)))
+// CHECK-NEXT: - Callback: RecursiveExpansion
+// CHECK-NEXT:   MacroNameTok: ZERO
+// CHECK-NEXT: - Callback: MacroExpands
+// CHECK-NEXT:   MacroNameTok: ZERO
+// CHECK-NEXT:   MacroDefinition: [(local)]
+// CHECK-NEXT:   Range: ["{{.*}}{{[/\\]}}pp-trace-verbose.cpp:12:21", "{{.*}}{{[/\\]}}pp-trace-verbose.cpp:12:21"]
+// CHECK-NEXT:   ExpandedTokens: 0
+// CHECK-NEXT: - Callback: RecursiveExpansion
+// CHECK-NEXT:   MacroNameTok: SQ
+// CHECK-NEXT: - Callback: RecursiveExpansion
+// CHECK-NEXT:   MacroNameTok: TWO
+// CHECK-NEXT: - Callback: RecursiveExpansion
+// CHECK-NEXT:   MacroNameTok: ZERO
+// CHECK-NEXT: - Callback: MacroExpands
+// CHECK-NEXT:   MacroNameTok: SQ
+// CHECK-NEXT:   MacroDefinition: [(local)]
+// CHECK-NEXT:   Range: ["{{.*}}{{[/\\]}}pp-trace-verbose.cpp:12:27", "{{.*}}{{[/\\]}}pp-trace-verbose.cpp:12:40"]
+// CHECK-NEXT:   Args:
+// CHECK-NEXT:   - a: TWO-ZERO
+// CHECK-NEXT:   ExpandedTokens: (MUL(TWO-ZERO,TWO-ZERO))
+// CHECK-NEXT: - Callback: RecursiveExpansion
+// CHECK-NEXT:   MacroNameTok: TWO
+// CHECK-NEXT: - Callback: MacroExpands
+// CHECK-NEXT:   MacroNameTok: TWO
+// CHECK-NEXT:   MacroDefinition: [(local)]
+// CHECK-NEXT:   Range: ["{{.*}}{{[/\\]}}pp-trace-verbose.cpp:12:30", "{{.*}}{{[/\\]}}pp-trace-verbose.cpp:12:30"]
+// CHECK-NEXT:   ExpandedTokens: 2
+// CHECK-NEXT: - Callback: RecursiveExpansion
+// CHECK-NEXT:   MacroNameTok: ZERO
+// CHECK-NEXT: - Callback: MacroExpands
+// CHECK-NEXT:   MacroNameTok: ZERO
+// CHECK-NEXT:   MacroDefinition: [(local)]
+// CHECK-NEXT:   Range: ["{{.*}}{{[/\\]}}pp-trace-verbose.cpp:12:36", "{{.*}}{{[/\\]}}pp-trace-verbose.cpp:12:36"]
+// CHECK-NEXT:   ExpandedTokens: 0
+// CHECK-NEXT: - Callback: RecursiveExpansion
+// CHECK-NEXT:   MacroNameTok: MUL
+// CHECK-NEXT: - Callback: MacroExpands
+// CHECK-NEXT:   MacroNameTok: MUL
+// CHECK-NEXT:   MacroDefinition: [(local)]
+// CHECK-NEXT:   Range: [(nonfile), (nonfile)]
+// CHECK-NEXT:   Args:
+// CHECK-NEXT:   - LHS: 2-0
+// CHECK-NEXT:   - RHS: 2-0
+// CHECK-NEXT:   ExpandedTokens: ((2-0)*(2-0))
+// CHECK-NEXT: - Callback: MacroExpands
+// CHECK-NEXT:   MacroNameTok: ARGS2
+// CHECK-NEXT:   MacroDefinition: [(local)]
+// CHECK-NEXT:   Range: ["{{.*}}{{[/\\]}}pp-trace-verbose.cpp:12:46", "{{.*}}{{[/\\]}}pp-trace-verbose.cpp:12:65"]
+// CHECK-NEXT:   Args:
+// CHECK-NEXT:   - a: 2
+// CHECK-NEXT:   - __VA_ARGS__: 3,4,5,6
+// CHECK-NEXT:   ExpandedTokens: 2+ARGS(3,4,5,6)
+// CHECK-NEXT: - Callback: RecursiveExpansion
+// CHECK-NEXT:   MacroNameTok: ARGS
+// CHECK-NEXT: - Callback: MacroExpands
+// CHECK-NEXT:   MacroNameTok: ARGS
+// CHECK-NEXT:   MacroDefinition: [(local)]
+// CHECK-NEXT:   Range: [(nonfile), (nonfile)]
+// CHECK-NEXT:   Args:
+// CHECK-NEXT:   - __VA_ARGS__: 3,4,5,6
+// CHECK-NEXT:   ExpandedTokens: 3,4,5,6
+// CHECK-NEXT: - Callback: EndOfMainFile
+// CHECK-NEXT: ...
\ No newline at end of file
