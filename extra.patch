Index: pp-trace/ArgTokens.cpp
===================================================================
--- pp-trace/ArgTokens.cpp	(nonexistent)
+++ pp-trace/ArgTokens.cpp	(working copy)
@@ -0,0 +1,33 @@
+#include "ArgTokens.h"
+
+void ArgTokens::Init(const MacroDefinition &MD,
+    const clang::MacroArgs *ActArgs, clang::Preprocessor& PP) {
+
+    if (!ActArgs) {
+        return;
+    }
+
+    if (IsInitialized()) {
+        Destroy();
+    }
+
+    const auto DefArgs = MD.getMacroInfo()->args();
+
+    for (auto I = 0u, E = ActArgs->getNumArguments(); I < E; ++I) {
+        auto Current = ActArgs->getUnexpArgument(I);
+        auto TokenCount = ActArgs->getArgLength(Current) + 1;
+        E -= TokenCount;
+        --TokenCount;
+
+        Cache.push_back(std::make_tuple(DefArgs[I]->getName(),
+        std::tuple_element<1, decltype(Cache)::value_type>::type()));
+        for (auto TokenIndex = 0u; TokenIndex < TokenCount; ++TokenIndex, ++Current) {
+            std::get<1>(Cache.back()).push_back(PP.getSpelling(*Current));
+        }
+    }
+}
+
+void ArgTokens::Destroy() {
+    Cache.clear();
+}
+
Index: pp-trace/ArgTokens.h
===================================================================
--- pp-trace/ArgTokens.h	(nonexistent)
+++ pp-trace/ArgTokens.h	(working copy)
@@ -0,0 +1,37 @@
+#ifndef PPTRACE_ARGTOKENS_H
+#define PPTRACE_ARGTOKENS_H
+
+#include "clang/Lex/Preprocessor.h"
+#include "clang/Lex/MacroArgs.h"
+
+#include <vector>
+
+using namespace clang;
+
+class ArgTokens {
+private:
+
+    // A vector of tuples of strings(parameter) and vectors of (actual args)
+    std::vector<
+        std::tuple<
+            std::string,
+            std::vector<std::string>
+        >
+    > Cache;
+
+public:
+
+    void Init(const MacroDefinition &MacroDefinition, const MacroArgs *ActualArgs,
+    Preprocessor& PP);
+
+    decltype(Cache.cbegin()) begin() const { return Cache.cbegin(); }
+    decltype(Cache.cend()) end() const { return Cache.cend(); }
+    decltype(Cache.size()) size() const { return Cache.size(); }
+
+    bool IsInitialized() const { return !Cache.empty(); }
+
+    void Destroy();
+};
+
+
+#endif // PPTRACE_ARGTOKENS_H
Index: pp-trace/CallbackCall.h
===================================================================
--- pp-trace/CallbackCall.h	(nonexistent)
+++ pp-trace/CallbackCall.h	(working copy)
@@ -0,0 +1,118 @@
+#ifndef PPTRACE_CALLBACKCALL_H
+#define PPTRACE_CALLBACKCALL_H
+
+#include "ArgTokens.h"
+#include "llvm/ADT/StringRef.h"
+#include "llvm/ADT/SmallSet.h"
+#include "clang/Lex/Preprocessor.h"
+#include "clang/Lex/MacroArgs.h"
+#include <string>
+#include <vector>
+
+
+/// \brief This class represents one callback function argument by name
+///   and value.
+struct Argument {
+    std::string Name;
+    std::string Value;
+};
+
+/// \brief This class represents one callback call by name and an array
+///   of arguments.
+class CallbackCall {
+public:
+    CallbackCall(llvm::StringRef Name) : Name(Name) {}
+    CallbackCall() = default;
+
+    std::string Name;
+    std::vector<Argument> Arguments;
+};
+
+class CallbackCalls {
+private:
+
+    /// \brief Callback trace information.
+    /// We use a reference so the trace will be preserved for the caller
+    /// after this object is destructed.
+    std::vector<CallbackCall> Calls;
+
+public:
+    CallbackCalls(llvm::SmallSet<std::string, 4> &Ignore);
+    virtual ~CallbackCalls() {}
+
+    decltype(Calls.cbegin()) begin() const { return Calls.cbegin(); }
+    decltype(Calls.cend()) end() const { return Calls.cend(); }
+
+    /// \brief Start a new callback.
+    void beginCallback(const char *Name);
+
+    /// \brief Append a bool argument to the top trace item.
+    virtual void appendArgument(const char *Name, bool Value);
+
+    /// \brief Append an int argument to the top trace item.
+    virtual void appendArgument(const char *Name, int Value);
+
+    /// \brief Append a string argument to the top trace item.
+    virtual void appendArgument(const char *Name, const char *Value);
+
+    /// \brief Append a string reference object argument to the top trace item.
+    virtual void appendArgument(const char *Name, llvm::StringRef Value);
+
+    /// \brief Append a string object argument to the top trace item.
+    virtual void appendArgument(const char *Name, const std::string &Value);
+
+    /// \brief Append a token argument to the top trace item.
+    virtual void appendArgument(const char *Name, const clang::Token &Value, clang::Preprocessor& PP);
+
+    /// \brief Append an enum argument to the top trace item.
+    virtual void appendArgument(const char *Name, int Value, const char *const Strings[]);
+
+    /// \brief Append a FileID argument to the top trace item.
+    virtual void appendArgument(const char *Name, clang::FileID Value, clang::Preprocessor& PP);
+
+    /// \brief Append a FileEntry argument to the top trace item.
+    virtual void appendArgument(const char *Name, const clang::FileEntry *Value);
+
+    /// \brief Append a SourceLocation argument to the top trace item.
+    virtual void appendArgument(const char *Name, clang::SourceLocation Value, clang::Preprocessor& PP);
+
+    /// \brief Append a SourceRange argument to the top trace item.
+    virtual void appendArgument(const char *Name, clang::SourceRange Value, clang::Preprocessor& PP);
+
+    /// \brief Append a CharSourceRange argument to the top trace item.
+    virtual void appendArgument(const char *Name, clang::CharSourceRange Value, clang::Preprocessor& PP);
+
+    /// \brief Append a ModuleIdPath argument to the top trace item.
+    virtual void appendArgument(const char *Name, clang::ModuleIdPath Value, clang::Preprocessor& PP);
+
+    /// \brief Append an IdentifierInfo argument to the top trace item.
+    virtual void appendArgument(const char *Name, const clang::IdentifierInfo *Value);
+
+    /// \brief Append a MacroDirective argument to the top trace item.
+    virtual void appendArgument(const char *Name, const clang::MacroDirective *Value);
+
+    /// \brief Append a MacroDefinition argument to the top trace item.
+    virtual void appendArgument(const char *Name, const clang::MacroDefinition &Value);
+
+    /// \brief Append a Module argument to the top trace item.
+    virtual void appendArgument(const char *Name, const clang::Module *Value);
+
+    /// \brief Append an ArgTokens argument to the top trace item.
+    virtual void appendArgument(const char *Name, const ArgTokens *Args);
+
+    /// \brief Append a double-quoted argument to the top trace item.
+    void appendQuotedArgument(const char *Name, const std::string &Value);
+
+    /// \brief Append a double-quoted file path argument to the top trace item.
+    void appendFilePathArgument(const char *Name, llvm::StringRef Value);
+
+private:
+
+    /// \brief Inhibit trace while this is set.
+    bool DisableTrace;
+
+    /// \brief Names of callbacks to ignore.
+    llvm::SmallSet<std::string, 4> &Ignore;
+};
+
+#endif // PPTRACE_CALLBACKCALL_H
Index: pp-trace/CallbackCalls.cpp
===================================================================
--- pp-trace/CallbackCalls.cpp	(nonexistent)
+++ pp-trace/CallbackCalls.cpp	(working copy)
@@ -0,0 +1,235 @@
+#include "CallbackCall.h"
+#include "Utils.h"
+#include "clang/Lex/Preprocessor.h"
+
+
+// MacroDirective::Kind strings.
+static const char *const MacroDirectiveKindStrings[] = {
+	"MD_Define", "MD_Undefine", "MD_Visibility"
+};
+
+CallbackCalls::CallbackCalls(llvm::SmallSet<std::string, 4> &Ignore)
+	: Ignore(Ignore) { }
+
+// Start a new callback.
+void CallbackCalls::beginCallback(const char *Name) {
+    DisableTrace = Ignore.count(std::string(Name));
+    if (DisableTrace)
+        return;
+    Calls.push_back(CallbackCall(Name));
+}
+
+// Append a bool argument to the top trace item.
+void CallbackCalls::appendArgument(const char *Name, bool Value) {
+    appendArgument(Name, (Value ? "true" : "false"));
+}
+
+// Append an int argument to the top trace item.
+void CallbackCalls::appendArgument(const char *Name, int Value) {
+    std::string Str;
+    llvm::raw_string_ostream SS(Str);
+    SS << Value;
+    appendArgument(Name, SS.str());
+}
+
+// Append a string argument to the top trace item.
+void CallbackCalls::appendArgument(const char *Name, const char *Value) {
+    if (DisableTrace)
+        return;
+    Calls.back().Arguments.push_back(Argument{ Name, Value });
+}
+
+// Append a string object argument to the top trace item.
+void CallbackCalls::appendArgument(const char *Name,
+                                        llvm::StringRef Value) {
+    appendArgument(Name, Value.str());
+}
+
+// Append a string object argument to the top trace item.
+void CallbackCalls::appendArgument(const char *Name,
+                                        const std::string &Value) {
+    appendArgument(Name, Value.c_str());
+}
+
+// Append a token argument to the top trace item.
+void CallbackCalls::appendArgument(const char *Name,
+                                        const clang::Token &Value,
+										clang::Preprocessor& PP) {
+    appendArgument(Name, PP.getSpelling(Value));
+}
+
+// Append an enum argument to the top trace item.
+void CallbackCalls::appendArgument(const char *Name, int Value,
+                                        const char *const Strings[]) {
+    appendArgument(Name, Strings[Value]);
+}
+
+// Append a FileID argument to the top trace item.
+void CallbackCalls::appendArgument(const char *Name, clang::FileID Value,
+										clang::Preprocessor& PP) {
+    if (Value.isInvalid()) {
+        appendArgument(Name, "(invalid)");
+        return;
+    }
+    const clang::FileEntry *FileEntry =
+      PP.getSourceManager().getFileEntryForID(Value);
+    if (!FileEntry) {
+        appendArgument(Name, "(getFileEntryForID failed)");
+        return;
+    }
+    appendFilePathArgument(Name, FileEntry->getName());
+}
+
+// Append a FileEntry argument to the top trace item.
+void CallbackCalls::appendArgument(const char *Name,
+                                        const clang::FileEntry *Value) {
+    if (!Value) {
+        appendArgument(Name, "(null)");
+        return;
+    }
+    appendFilePathArgument(Name, Value->getName());
+}
+
+// Append a SourceLocation argument to the top trace item.
+void CallbackCalls::appendArgument(const char *Name,
+                                        clang::SourceLocation Value,
+										clang::Preprocessor& PP) {
+    if (Value.isInvalid()) {
+        appendArgument(Name, "(invalid)");
+        return;
+    }
+    appendArgument(Name, getSourceLocationString(PP, Value).c_str());
+}
+
+// Append a SourceRange argument to the top trace item.
+void CallbackCalls::appendArgument(const char *Name,
+                                        clang::SourceRange Value,
+										clang::Preprocessor& PP) {
+    if (DisableTrace)
+        return;
+    if (Value.isInvalid()) {
+        appendArgument(Name, "(invalid)");
+        return;
+    }
+    std::string Str;
+    llvm::raw_string_ostream SS(Str);
+    SS << "[" << getSourceLocationString(PP, Value.getBegin()) << ", "
+        << getSourceLocationString(PP, Value.getEnd()) << "]";
+    appendArgument(Name, SS.str());
+}
+
+// Append a CharSourceRange argument to the top trace item.
+void CallbackCalls::appendArgument(const char *Name,
+                                        clang::CharSourceRange Value,
+										clang::Preprocessor& PP) {
+    if (Value.isInvalid()) {
+        appendArgument(Name, "(invalid)");
+        return;
+    }
+    appendArgument(Name, getSourceString<clang::CharSourceRange>(PP, Value).str().c_str());
+}
+
+// Append a SourceLocation argument to the top trace item.
+void CallbackCalls::appendArgument(const char *Name,
+                                        clang::ModuleIdPath Value,
+										clang::Preprocessor& PP) {
+    if (DisableTrace)
+        return;
+    std::string Str;
+    llvm::raw_string_ostream SS(Str);
+    SS << "[";
+    for (int I = 0, E = Value.size(); I != E; ++I) {
+        if (I)
+          SS << ", ";
+        SS << "{"
+           << "Name: " << Value[I].first->getName() << ", "
+           << "Loc: " << getSourceLocationString(PP, Value[I].second) << "}";
+    }
+    SS << "]";
+    appendArgument(Name, SS.str());
+}
+
+// Append an IdentifierInfo argument to the top trace item.
+void CallbackCalls::appendArgument(const char *Name,
+                                        const clang::IdentifierInfo *Value) {
+    if (!Value) {
+        appendArgument(Name, "(null)");
+        return;
+    }
+    appendArgument(Name, Value->getName().str().c_str());
+}
+
+// Append a MacroDirective argument to the top trace item.
+void CallbackCalls::appendArgument(const char *Name,
+                                        const clang::MacroDirective *Value) {
+    if (!Value) {
+        appendArgument(Name, "(null)");
+        return;
+    }
+    appendArgument(Name, MacroDirectiveKindStrings[Value->getKind()]);
+}
+
+// Append a MacroDefinition argument to the top trace item.
+void CallbackCalls::appendArgument(const char *Name,
+                                        const clang::MacroDefinition &Value) {
+    std::string Str;
+    llvm::raw_string_ostream SS(Str);
+    SS << "[";
+    bool Any = false;
+    if (Value.getLocalDirective()) {
+        SS << "(local)";
+        Any = true;
+    }
+    for (auto *MM : Value.getModuleMacros()) {
+        if (Any)
+            SS << ", ";
+        SS << MM->getOwningModule()->getFullModuleName();
+    }
+    SS << "]";
+    appendArgument(Name, SS.str());
+}
+
+// Append a Module argument to the top trace item.
+void CallbackCalls::appendArgument(const char *Name,
+                                        const clang::Module *Value) {
+    if (!Value) {
+        appendArgument(Name, "(null)");
+        return;
+    }
+    appendArgument(Name, Value->Name.c_str());
+}
+
+// Append an ArgTokens argument to the top trace item.
+void CallbackCalls::appendArgument(const char *Name, const ArgTokens *Args) {
+    std::string s;
+    llvm::raw_string_ostream SS(s);
+    for (const auto& arg : *Args) {
+        SS << "\n  - ";
+        SS << std::get<0>(arg) << ": ";
+        const auto& subargs = std::get<1>(arg);
+
+        for (auto subarg = subargs.cbegin(); subarg < subargs.cend(); ++subarg) {
+            SS << *subarg;
+        }
+    }
+
+    appendArgument(Name, SS.str());
+}
+
+// Append a double-quoted argument to the top trace item.
+void CallbackCalls::appendQuotedArgument(const char *Name,
+                                              const std::string &Value) {
+    std::string Str;
+    llvm::raw_string_ostream SS(Str);
+    SS << "\"" << Value << "\"";
+    appendArgument(Name, SS.str());
+}
+
+// Append a double-quoted file path argument to the top trace item.
+void CallbackCalls::appendFilePathArgument(const char *Name,
+                                                llvm::StringRef Value) {
+    std::string Path(Value);
+    // YAML treats backslash as escape, so use forward slashes.
+    std::replace(Path.begin(), Path.end(), '\\', '/');
+    appendQuotedArgument(Name, Path);
+}
Index: pp-trace/CMakeLists.txt
===================================================================
--- pp-trace/CMakeLists.txt	(revision 302379)
+++ pp-trace/CMakeLists.txt	(working copy)
@@ -5,6 +5,9 @@
 add_clang_executable(pp-trace
   PPTrace.cpp
   PPCallbacksTracker.cpp
+  VerboseDecorator.cpp
+  CallbackCalls.cpp
+  ArgTokens.cpp
   )
 
 target_link_libraries(pp-trace
Index: pp-trace/PPCallbacksTracker.cpp
===================================================================
--- pp-trace/PPCallbacksTracker.cpp	(revision 302379)
+++ pp-trace/PPCallbacksTracker.cpp	(working copy)
@@ -15,42 +15,9 @@
 //===----------------------------------------------------------------------===//
 
 #include "PPCallbacksTracker.h"
-#include "clang/Lex/MacroArgs.h"
 #include "llvm/Support/raw_ostream.h"
 
-// Utility functions.
 
-// Get a "file:line:column" source location string.
-static std::string getSourceLocationString(clang::Preprocessor &PP,
-                                           clang::SourceLocation Loc) {
-  if (Loc.isInvalid())
-    return std::string("(none)");
-
-  if (Loc.isFileID()) {
-    clang::PresumedLoc PLoc = PP.getSourceManager().getPresumedLoc(Loc);
-
-    if (PLoc.isInvalid()) {
-      return std::string("(invalid)");
-    }
-
-    std::string Str;
-    llvm::raw_string_ostream SS(Str);
-
-    // The macro expansion and spelling pos is identical for file locs.
-    SS << "\"" << PLoc.getFilename() << ':' << PLoc.getLine() << ':'
-       << PLoc.getColumn() << "\"";
-
-    std::string Result = SS.str();
-
-    // YAML treats backslash as escape, so use forward slashes.
-    std::replace(Result.begin(), Result.end(), '\\', '/');
-
-    return Result;
-  }
-
-  return std::string("(nonfile)");
-}
-
 // Enum string tables.
 
 // FileChangeReason strings.
@@ -62,10 +29,6 @@
 static const char *const CharacteristicKindStrings[] = { "C_User", "C_System",
                                                          "C_ExternCSystem" };
 
-// MacroDirective::Kind strings.
-static const char *const MacroDirectiveKindStrings[] = {
-  "MD_Define","MD_Undefine", "MD_Visibility"
-};
 
 // PragmaIntroducerKind strings.
 static const char *const PragmaIntroducerKindStrings[] = { "PIK_HashPragma",
@@ -89,13 +52,25 @@
 
 // PPCallbacksTracker functions.
 
-PPCallbacksTracker::PPCallbacksTracker(llvm::SmallSet<std::string, 4> &Ignore,
-                                       std::vector<CallbackCall> &CallbackCalls,
+PPCallbacksTracker::PPCallbacksTracker(CallbackCalls &CallbackCalls,
                                        clang::Preprocessor &PP)
-    : CallbackCalls(CallbackCalls), Ignore(Ignore), PP(PP) {}
+    : Calls(CallbackCalls), PP(PP) {
+  llvm::outs() << "PPCallbacksTracker CTOR\n";
+}
 
-PPCallbacksTracker::~PPCallbacksTracker() {}
 
+PPCallbacksTracker::PPCallbacksTracker(PPCallbacksTracker&& o)
+  : Calls(o.Calls), PP(o.PP) {
+
+  llvm::outs() << "MOVE CTOR\n";
+}
+
+PPCallbacksTracker& PPCallbacksTracker::operator=(PPCallbacksTracker&& o) {
+  llvm::outs() << "MOVE ASSIGN\n";
+
+  return *this;
+}
+
 // Callback functions.
 
 // Callback invoked whenever a source file is entered or exited.
@@ -102,11 +77,11 @@
 void PPCallbacksTracker::FileChanged(
     clang::SourceLocation Loc, clang::PPCallbacks::FileChangeReason Reason,
     clang::SrcMgr::CharacteristicKind FileType, clang::FileID PrevFID) {
-  beginCallback("FileChanged");
-  appendArgument("Loc", Loc);
-  appendArgument("Reason", Reason, FileChangeReasonStrings);
-  appendArgument("FileType", FileType, CharacteristicKindStrings);
-  appendArgument("PrevFID", PrevFID);
+  Calls.beginCallback("FileChanged");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("Reason", Reason, FileChangeReasonStrings);
+  Calls.appendArgument("FileType", FileType, CharacteristicKindStrings);
+  Calls.appendArgument("PrevFID", PrevFID, PP);
 }
 
 // Callback invoked whenever a source file is skipped as the result
@@ -115,10 +90,10 @@
 PPCallbacksTracker::FileSkipped(const clang::FileEntry &SkippedFile,
                                 const clang::Token &FilenameTok,
                                 clang::SrcMgr::CharacteristicKind FileType) {
-  beginCallback("FileSkipped");
-  appendArgument("ParentFile", &SkippedFile);
-  appendArgument("FilenameTok", FilenameTok);
-  appendArgument("FileType", FileType, CharacteristicKindStrings);
+  Calls.beginCallback("FileSkipped");
+  Calls.appendArgument("ParentFile", &SkippedFile);
+  Calls.appendArgument("FilenameTok", FilenameTok, PP);
+  Calls.appendArgument("FileType", FileType, CharacteristicKindStrings);
 }
 
 // Callback invoked whenever an inclusion directive results in a
@@ -126,8 +101,8 @@
 bool
 PPCallbacksTracker::FileNotFound(llvm::StringRef FileName,
                                  llvm::SmallVectorImpl<char> &RecoveryPath) {
-  beginCallback("FileNotFound");
-  appendFilePathArgument("FileName", FileName);
+  Calls.beginCallback("FileNotFound");
+  Calls.appendFilePathArgument("FileName", FileName);
   return false;
 }
 
@@ -140,15 +115,15 @@
     clang::CharSourceRange FilenameRange, const clang::FileEntry *File,
     llvm::StringRef SearchPath, llvm::StringRef RelativePath,
     const clang::Module *Imported) {
-  beginCallback("InclusionDirective");
-  appendArgument("IncludeTok", IncludeTok);
-  appendFilePathArgument("FileName", FileName);
-  appendArgument("IsAngled", IsAngled);
-  appendArgument("FilenameRange", FilenameRange);
-  appendArgument("File", File);
-  appendFilePathArgument("SearchPath", SearchPath);
-  appendFilePathArgument("RelativePath", RelativePath);
-  appendArgument("Imported", Imported);
+  Calls.beginCallback("InclusionDirective");
+  Calls.appendArgument("IncludeTok", IncludeTok, PP);
+  Calls.appendFilePathArgument("FileName", FileName);
+  Calls.appendArgument("IsAngled", IsAngled);
+  Calls.appendArgument("FilenameRange", FilenameRange, PP);
+  Calls.appendArgument("File", File);
+  Calls.appendFilePathArgument("SearchPath", SearchPath);
+  Calls.appendFilePathArgument("RelativePath", RelativePath);
+  Calls.appendArgument("Imported", Imported);
 }
 
 // Callback invoked whenever there was an explicit module-import
@@ -156,21 +131,21 @@
 void PPCallbacksTracker::moduleImport(clang::SourceLocation ImportLoc,
                                       clang::ModuleIdPath Path,
                                       const clang::Module *Imported) {
-  beginCallback("moduleImport");
-  appendArgument("ImportLoc", ImportLoc);
-  appendArgument("Path", Path);
-  appendArgument("Imported", Imported);
+  Calls.beginCallback("moduleImport");
+  Calls.appendArgument("ImportLoc", ImportLoc, PP);
+  Calls.appendArgument("Path", Path, PP);
+  Calls.appendArgument("Imported", Imported);
 }
 
 // Callback invoked when the end of the main file is reached.
 // No subsequent callbacks will be made.
-void PPCallbacksTracker::EndOfMainFile() { beginCallback("EndOfMainFile"); }
+void PPCallbacksTracker::EndOfMainFile() { Calls.beginCallback("EndOfMainFile"); }
 
 // Callback invoked when a #ident or #sccs directive is read.
 void PPCallbacksTracker::Ident(clang::SourceLocation Loc, llvm::StringRef Str) {
-  beginCallback("Ident");
-  appendArgument("Loc", Loc);
-  appendArgument("Str", Str);
+  Calls.beginCallback("Ident");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("Str", Str);
 }
 
 // Callback invoked when start reading any pragma directive.
@@ -177,9 +152,9 @@
 void
 PPCallbacksTracker::PragmaDirective(clang::SourceLocation Loc,
                                     clang::PragmaIntroducerKind Introducer) {
-  beginCallback("PragmaDirective");
-  appendArgument("Loc", Loc);
-  appendArgument("Introducer", Introducer, PragmaIntroducerKindStrings);
+  Calls.beginCallback("PragmaDirective");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("Introducer", Introducer, PragmaIntroducerKindStrings);
 }
 
 // Callback invoked when a #pragma comment directive is read.
@@ -186,10 +161,10 @@
 void PPCallbacksTracker::PragmaComment(clang::SourceLocation Loc,
                                        const clang::IdentifierInfo *Kind,
                                        llvm::StringRef Str) {
-  beginCallback("PragmaComment");
-  appendArgument("Loc", Loc);
-  appendArgument("Kind", Kind);
-  appendArgument("Str", Str);
+  Calls.beginCallback("PragmaComment");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("Kind", Kind);
+  Calls.appendArgument("Str", Str);
 }
 
 // Callback invoked when a #pragma detect_mismatch directive is
@@ -197,18 +172,18 @@
 void PPCallbacksTracker::PragmaDetectMismatch(clang::SourceLocation Loc,
                                               llvm::StringRef Name,
                                               llvm::StringRef Value) {
-  beginCallback("PragmaDetectMismatch");
-  appendArgument("Loc", Loc);
-  appendArgument("Name", Name);
-  appendArgument("Value", Value);
+  Calls.beginCallback("PragmaDetectMismatch");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("Name", Name);
+  Calls.appendArgument("Value", Value);
 }
 
 // Callback invoked when a #pragma clang __debug directive is read.
 void PPCallbacksTracker::PragmaDebug(clang::SourceLocation Loc,
                                      llvm::StringRef DebugType) {
-  beginCallback("PragmaDebug");
-  appendArgument("Loc", Loc);
-  appendArgument("DebugType", DebugType);
+  Calls.beginCallback("PragmaDebug");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("DebugType", DebugType);
 }
 
 // Callback invoked when a #pragma message directive is read.
@@ -215,11 +190,11 @@
 void PPCallbacksTracker::PragmaMessage(
     clang::SourceLocation Loc, llvm::StringRef Namespace,
     clang::PPCallbacks::PragmaMessageKind Kind, llvm::StringRef Str) {
-  beginCallback("PragmaMessage");
-  appendArgument("Loc", Loc);
-  appendArgument("Namespace", Namespace);
-  appendArgument("Kind", Kind, PragmaMessageKindStrings);
-  appendArgument("Str", Str);
+  Calls.beginCallback("PragmaMessage");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("Namespace", Namespace);
+  Calls.appendArgument("Kind", Kind, PragmaMessageKindStrings);
+  Calls.appendArgument("Str", Str);
 }
 
 // Callback invoked when a #pragma gcc dianostic push directive
@@ -226,9 +201,9 @@
 // is read.
 void PPCallbacksTracker::PragmaDiagnosticPush(clang::SourceLocation Loc,
                                               llvm::StringRef Namespace) {
-  beginCallback("PragmaDiagnosticPush");
-  appendArgument("Loc", Loc);
-  appendArgument("Namespace", Namespace);
+  Calls.beginCallback("PragmaDiagnosticPush");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("Namespace", Namespace);
 }
 
 // Callback invoked when a #pragma gcc dianostic pop directive
@@ -235,9 +210,9 @@
 // is read.
 void PPCallbacksTracker::PragmaDiagnosticPop(clang::SourceLocation Loc,
                                              llvm::StringRef Namespace) {
-  beginCallback("PragmaDiagnosticPop");
-  appendArgument("Loc", Loc);
-  appendArgument("Namespace", Namespace);
+  Calls.beginCallback("PragmaDiagnosticPop");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("Namespace", Namespace);
 }
 
 // Callback invoked when a #pragma gcc dianostic directive is read.
@@ -245,11 +220,11 @@
                                           llvm::StringRef Namespace,
                                           clang::diag::Severity Mapping,
                                           llvm::StringRef Str) {
-  beginCallback("PragmaDiagnostic");
-  appendArgument("Loc", Loc);
-  appendArgument("Namespace", Namespace);
-  appendArgument("Mapping", (unsigned)Mapping, MappingStrings);
-  appendArgument("Str", Str);
+  Calls.beginCallback("PragmaDiagnostic");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("Namespace", Namespace);
+  Calls.appendArgument("Mapping", (unsigned)Mapping, MappingStrings);
+  Calls.appendArgument("Str", Str);
 }
 
 // Called when an OpenCL extension is either disabled or
@@ -257,11 +232,11 @@
 void PPCallbacksTracker::PragmaOpenCLExtension(
     clang::SourceLocation NameLoc, const clang::IdentifierInfo *Name,
     clang::SourceLocation StateLoc, unsigned State) {
-  beginCallback("PragmaOpenCLExtension");
-  appendArgument("NameLoc", NameLoc);
-  appendArgument("Name", Name);
-  appendArgument("StateLoc", StateLoc);
-  appendArgument("State", (int)State);
+  Calls.beginCallback("PragmaOpenCLExtension");
+  Calls.appendArgument("NameLoc", NameLoc, PP);
+  Calls.appendArgument("Name", Name);
+  Calls.appendArgument("StateLoc", StateLoc, PP);
+  Calls.appendArgument("State", (int)State);
 }
 
 // Callback invoked when a #pragma warning directive is read.
@@ -268,9 +243,9 @@
 void PPCallbacksTracker::PragmaWarning(clang::SourceLocation Loc,
                                        llvm::StringRef WarningSpec,
                                        llvm::ArrayRef<int> Ids) {
-  beginCallback("PragmaWarning");
-  appendArgument("Loc", Loc);
-  appendArgument("WarningSpec", WarningSpec);
+  Calls.beginCallback("PragmaWarning");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("WarningSpec", WarningSpec);
 
   std::string Str;
   llvm::raw_string_ostream SS(Str);
@@ -281,21 +256,21 @@
     SS << Ids[i];
   }
   SS << "]";
-  appendArgument("Ids", SS.str());
+  Calls.appendArgument("Ids", SS.str());
 }
 
 // Callback invoked when a #pragma warning(push) directive is read.
 void PPCallbacksTracker::PragmaWarningPush(clang::SourceLocation Loc,
                                            int Level) {
-  beginCallback("PragmaWarningPush");
-  appendArgument("Loc", Loc);
-  appendArgument("Level", Level);
+  Calls.beginCallback("PragmaWarningPush");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("Level", Level);
 }
 
 // Callback invoked when a #pragma warning(pop) directive is read.
 void PPCallbacksTracker::PragmaWarningPop(clang::SourceLocation Loc) {
-  beginCallback("PragmaWarningPop");
-  appendArgument("Loc", Loc);
+  Calls.beginCallback("PragmaWarningPop");
+  Calls.appendArgument("Loc", Loc, PP);
 }
 
 // Called by Preprocessor::HandleMacroExpandedIdentifier when a
@@ -305,11 +280,15 @@
                                  const clang::MacroDefinition &MacroDefinition,
                                  clang::SourceRange Range,
                                  const clang::MacroArgs *Args) {
-  beginCallback("MacroExpands");
-  appendArgument("MacroNameTok", MacroNameTok);
-  appendArgument("MacroDefinition", MacroDefinition);
-  appendArgument("Range", Range);
-  appendArgument("Args", Args);
+  Calls.beginCallback("MacroExpands");
+  Calls.appendArgument("MacroNameTok", MacroNameTok, PP);
+  Calls.appendArgument("MacroDefinition", MacroDefinition);
+  Calls.appendArgument("Range", Range, PP);
+
+  if (MacroDefinition.getMacroInfo()->isFunctionLike()) {
+    CurrArgs.Init(MacroDefinition, Args, PP);
+    Calls.appendArgument("Args", &CurrArgs);
+  }
 }
 
 // Hook called whenever a macro definition is seen.
@@ -316,9 +295,9 @@
 void
 PPCallbacksTracker::MacroDefined(const clang::Token &MacroNameTok,
                                  const clang::MacroDirective *MacroDirective) {
-  beginCallback("MacroDefined");
-  appendArgument("MacroNameTok", MacroNameTok);
-  appendArgument("MacroDirective", MacroDirective);
+  Calls.beginCallback("MacroDefined");
+  Calls.appendArgument("MacroNameTok", MacroNameTok, PP);
+  Calls.appendArgument("MacroDirective", MacroDirective);
 }
 
 // Hook called whenever a macro #undef is seen.
@@ -326,9 +305,9 @@
     const clang::Token &MacroNameTok,
     const clang::MacroDefinition &MacroDefinition,
     const clang::MacroDirective *Undef) {
-  beginCallback("MacroUndefined");
-  appendArgument("MacroNameTok", MacroNameTok);
-  appendArgument("MacroDefinition", MacroDefinition);
+  Calls.beginCallback("MacroUndefined");
+  Calls.appendArgument("MacroNameTok", MacroNameTok, PP);
+  Calls.appendArgument("MacroDefinition", MacroDefinition);
 }
 
 // Hook called whenever the 'defined' operator is seen.
@@ -335,16 +314,16 @@
 void PPCallbacksTracker::Defined(const clang::Token &MacroNameTok,
                                  const clang::MacroDefinition &MacroDefinition,
                                  clang::SourceRange Range) {
-  beginCallback("Defined");
-  appendArgument("MacroNameTok", MacroNameTok);
-  appendArgument("MacroDefinition", MacroDefinition);
-  appendArgument("Range", Range);
+  Calls.beginCallback("Defined");
+  Calls.appendArgument("MacroNameTok", MacroNameTok, PP);
+  Calls.appendArgument("MacroDefinition", MacroDefinition);
+  Calls.appendArgument("Range", Range, PP);
 }
 
 // Hook called when a source range is skipped.
 void PPCallbacksTracker::SourceRangeSkipped(clang::SourceRange Range) {
-  beginCallback("SourceRangeSkipped");
-  appendArgument("Range", Range);
+  Calls.beginCallback("SourceRangeSkipped");
+  Calls.appendArgument("Range", Range, PP);
 }
 
 // Hook called whenever an #if is seen.
@@ -351,10 +330,10 @@
 void PPCallbacksTracker::If(clang::SourceLocation Loc,
                             clang::SourceRange ConditionRange,
                             ConditionValueKind ConditionValue) {
-  beginCallback("If");
-  appendArgument("Loc", Loc);
-  appendArgument("ConditionRange", ConditionRange);
-  appendArgument("ConditionValue", ConditionValue, ConditionValueKindStrings);
+  Calls.beginCallback("If");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("ConditionRange", ConditionRange, PP);
+  Calls.appendArgument("ConditionValue", ConditionValue, ConditionValueKindStrings);
 }
 
 // Hook called whenever an #elif is seen.
@@ -362,11 +341,11 @@
                               clang::SourceRange ConditionRange,
                               ConditionValueKind ConditionValue,
                               clang::SourceLocation IfLoc) {
-  beginCallback("Elif");
-  appendArgument("Loc", Loc);
-  appendArgument("ConditionRange", ConditionRange);
-  appendArgument("ConditionValue", ConditionValue, ConditionValueKindStrings);
-  appendArgument("IfLoc", IfLoc);
+  Calls.beginCallback("Elif");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("ConditionRange", ConditionRange, PP);
+  Calls.appendArgument("ConditionValue", ConditionValue, ConditionValueKindStrings);
+  Calls.appendArgument("IfLoc", IfLoc, PP);
 }
 
 // Hook called whenever an #ifdef is seen.
@@ -373,10 +352,10 @@
 void PPCallbacksTracker::Ifdef(clang::SourceLocation Loc,
                                const clang::Token &MacroNameTok,
                                const clang::MacroDefinition &MacroDefinition) {
-  beginCallback("Ifdef");
-  appendArgument("Loc", Loc);
-  appendArgument("MacroNameTok", MacroNameTok);
-  appendArgument("MacroDefinition", MacroDefinition);
+  Calls.beginCallback("Ifdef");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("MacroNameTok", MacroNameTok, PP);
+  Calls.appendArgument("MacroDefinition", MacroDefinition);
 }
 
 // Hook called whenever an #ifndef is seen.
@@ -383,272 +362,34 @@
 void PPCallbacksTracker::Ifndef(clang::SourceLocation Loc,
                                 const clang::Token &MacroNameTok,
                                 const clang::MacroDefinition &MacroDefinition) {
-  beginCallback("Ifndef");
-  appendArgument("Loc", Loc);
-  appendArgument("MacroNameTok", MacroNameTok);
-  appendArgument("MacroDefinition", MacroDefinition);
+  Calls.beginCallback("Ifndef");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("MacroNameTok", MacroNameTok, PP);
+  Calls.appendArgument("MacroDefinition", MacroDefinition);
 }
 
 // Hook called whenever an #else is seen.
 void PPCallbacksTracker::Else(clang::SourceLocation Loc,
                               clang::SourceLocation IfLoc) {
-  beginCallback("Else");
-  appendArgument("Loc", Loc);
-  appendArgument("IfLoc", IfLoc);
+  Calls.beginCallback("Else");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("IfLoc", IfLoc, PP);
 }
 
 // Hook called whenever an #endif is seen.
 void PPCallbacksTracker::Endif(clang::SourceLocation Loc,
                                clang::SourceLocation IfLoc) {
-  beginCallback("Endif");
-  appendArgument("Loc", Loc);
-  appendArgument("IfLoc", IfLoc);
+  Calls.beginCallback("Endif");
+  Calls.appendArgument("Loc", Loc, PP);
+  Calls.appendArgument("IfLoc", IfLoc, PP);
 }
 
-// Helper functions.
-
-// Start a new callback.
-void PPCallbacksTracker::beginCallback(const char *Name) {
-  DisableTrace = Ignore.count(std::string(Name));
-  if (DisableTrace)
-    return;
-  CallbackCalls.push_back(CallbackCall(Name));
+void PPCallbacksTracker::RecursiveExpansion(const clang::Token & Tok)
+{
+  auto B = getCharacterData(PP, Tok.getLocation());
+  auto tok = llvm::StringRef(B, Tok.getLength());
+  Calls.beginCallback("RecursiveExpansion");
+  Calls.appendArgument("MacroNameTok", tok);
 }
 
-// Append a bool argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name, bool Value) {
-  appendArgument(Name, (Value ? "true" : "false"));
-}
-
-// Append an int argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name, int Value) {
-  std::string Str;
-  llvm::raw_string_ostream SS(Str);
-  SS << Value;
-  appendArgument(Name, SS.str());
-}
-
-// Append a string argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name, const char *Value) {
-  if (DisableTrace)
-    return;
-  CallbackCalls.back().Arguments.push_back(Argument(Name, Value));
-}
-
-// Append a string object argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name,
-                                        llvm::StringRef Value) {
-  appendArgument(Name, Value.str());
-}
-
-// Append a string object argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name,
-                                        const std::string &Value) {
-  appendArgument(Name, Value.c_str());
-}
-
-// Append a token argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name,
-                                        const clang::Token &Value) {
-  appendArgument(Name, PP.getSpelling(Value));
-}
-
-// Append an enum argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name, int Value,
-                                        const char *const Strings[]) {
-  appendArgument(Name, Strings[Value]);
-}
-
-// Append a FileID argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name, clang::FileID Value) {
-  if (Value.isInvalid()) {
-    appendArgument(Name, "(invalid)");
-    return;
-  }
-  const clang::FileEntry *FileEntry =
-      PP.getSourceManager().getFileEntryForID(Value);
-  if (!FileEntry) {
-    appendArgument(Name, "(getFileEntryForID failed)");
-    return;
-  }
-  appendFilePathArgument(Name, FileEntry->getName());
-}
-
-// Append a FileEntry argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name,
-                                        const clang::FileEntry *Value) {
-  if (!Value) {
-    appendArgument(Name, "(null)");
-    return;
-  }
-  appendFilePathArgument(Name, Value->getName());
-}
-
-// Append a SourceLocation argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name,
-                                        clang::SourceLocation Value) {
-  if (Value.isInvalid()) {
-    appendArgument(Name, "(invalid)");
-    return;
-  }
-  appendArgument(Name, getSourceLocationString(PP, Value).c_str());
-}
-
-// Append a SourceRange argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name,
-                                        clang::SourceRange Value) {
-  if (DisableTrace)
-    return;
-  if (Value.isInvalid()) {
-    appendArgument(Name, "(invalid)");
-    return;
-  }
-  std::string Str;
-  llvm::raw_string_ostream SS(Str);
-  SS << "[" << getSourceLocationString(PP, Value.getBegin()) << ", "
-     << getSourceLocationString(PP, Value.getEnd()) << "]";
-  appendArgument(Name, SS.str());
-}
-
-// Append a CharSourceRange argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name,
-                                        clang::CharSourceRange Value) {
-  if (Value.isInvalid()) {
-    appendArgument(Name, "(invalid)");
-    return;
-  }
-  appendArgument(Name, getSourceString(Value).str().c_str());
-}
-
-// Append a SourceLocation argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name,
-                                        clang::ModuleIdPath Value) {
-  if (DisableTrace)
-    return;
-  std::string Str;
-  llvm::raw_string_ostream SS(Str);
-  SS << "[";
-  for (int I = 0, E = Value.size(); I != E; ++I) {
-    if (I)
-      SS << ", ";
-    SS << "{"
-       << "Name: " << Value[I].first->getName() << ", "
-       << "Loc: " << getSourceLocationString(PP, Value[I].second) << "}";
-  }
-  SS << "]";
-  appendArgument(Name, SS.str());
-}
-
-// Append an IdentifierInfo argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name,
-                                        const clang::IdentifierInfo *Value) {
-  if (!Value) {
-    appendArgument(Name, "(null)");
-    return;
-  }
-  appendArgument(Name, Value->getName().str().c_str());
-}
-
-// Append a MacroDirective argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name,
-                                        const clang::MacroDirective *Value) {
-  if (!Value) {
-    appendArgument(Name, "(null)");
-    return;
-  }
-  appendArgument(Name, MacroDirectiveKindStrings[Value->getKind()]);
-}
-
-// Append a MacroDefinition argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name,
-                                        const clang::MacroDefinition &Value) {
-  std::string Str;
-  llvm::raw_string_ostream SS(Str);
-  SS << "[";
-  bool Any = false;
-  if (Value.getLocalDirective()) {
-    SS << "(local)";
-    Any = true;
-  }
-  for (auto *MM : Value.getModuleMacros()) {
-    if (Any) SS << ", ";
-    SS << MM->getOwningModule()->getFullModuleName();
-  }
-  SS << "]";
-  appendArgument(Name, SS.str());
-}
-
-// Append a MacroArgs argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name,
-                                        const clang::MacroArgs *Value) {
-  if (!Value) {
-    appendArgument(Name, "(null)");
-    return;
-  }
-  std::string Str;
-  llvm::raw_string_ostream SS(Str);
-  SS << "[";
-  // The argument tokens might include end tokens, so we reflect how
-  // how getUnexpArgument provides the arguments.
-  for (int I = 0, E = Value->getNumArguments(); I < E; ++I) {
-    const clang::Token *Current = Value->getUnexpArgument(I);
-    int TokenCount = Value->getArgLength(Current) + 1; // include EOF
-    E -= TokenCount;
-    if (I)
-      SS << ", ";
-    // We're assuming tokens are contiguous, as otherwise we have no
-    // other way to get at them.
-    --TokenCount;
-    for (int TokenIndex = 0; TokenIndex < TokenCount; ++TokenIndex, ++Current) {
-      if (TokenIndex)
-        SS << " ";
-      // We need to be careful here because the arguments might not be legal in
-      // YAML, so we use the token name for anything but identifiers and
-      // numeric literals.
-      if (Current->isAnyIdentifier() ||
-          Current->is(clang::tok::numeric_constant)) {
-        SS << PP.getSpelling(*Current);
-      } else {
-        SS << "<" << Current->getName() << ">";
-      }
-    }
-  }
-  SS << "]";
-  appendArgument(Name, SS.str());
-}
-
-// Append a Module argument to the top trace item.
-void PPCallbacksTracker::appendArgument(const char *Name,
-                                        const clang::Module *Value) {
-  if (!Value) {
-    appendArgument(Name, "(null)");
-    return;
-  }
-  appendArgument(Name, Value->Name.c_str());
-}
-
-// Append a double-quoted argument to the top trace item.
-void PPCallbacksTracker::appendQuotedArgument(const char *Name,
-                                              const std::string &Value) {
-  std::string Str;
-  llvm::raw_string_ostream SS(Str);
-  SS << "\"" << Value << "\"";
-  appendArgument(Name, SS.str());
-}
-
-// Append a double-quoted file path argument to the top trace item.
-void PPCallbacksTracker::appendFilePathArgument(const char *Name,
-                                                llvm::StringRef Value) {
-  std::string Path(Value);
-  // YAML treats backslash as escape, so use forward slashes.
-  std::replace(Path.begin(), Path.end(), '\\', '/');
-  appendQuotedArgument(Name, Path);
-}
-
-// Get the raw source string of the range.
-llvm::StringRef
-PPCallbacksTracker::getSourceString(clang::CharSourceRange Range) {
-  const char *B = PP.getSourceManager().getCharacterData(Range.getBegin());
-  const char *E = PP.getSourceManager().getCharacterData(Range.getEnd());
-  return llvm::StringRef(B, E - B);
-}
+// Helper functions.
Index: pp-trace/PPCallbacksTracker.h
===================================================================
--- pp-trace/PPCallbacksTracker.h	(revision 302379)
+++ pp-trace/PPCallbacksTracker.h	(working copy)
@@ -22,6 +22,8 @@
 #ifndef PPTRACE_PPCALLBACKSTRACKER_H
 #define PPTRACE_PPCALLBACKSTRACKER_H
 
+#include "CallbackCall.h"
+#include "ArgTokens.h"
 #include "clang/Lex/PPCallbacks.h"
 #include "clang/Lex/Preprocessor.h"
 #include "clang/Basic/SourceManager.h"
@@ -28,32 +30,10 @@
 #include "llvm/ADT/ArrayRef.h"
 #include "llvm/ADT/SmallSet.h"
 #include "llvm/ADT/StringRef.h"
+#include "Utils.h"
 #include <string>
 #include <vector>
 
-/// \brief This class represents one callback function argument by name
-///   and value.
-class Argument {
-public:
-  Argument(llvm::StringRef Name, llvm::StringRef Value)
-      : Name(Name), Value(Value) {}
-  Argument() = default;
-
-  std::string Name;
-  std::string Value;
-};
-
-/// \brief This class represents one callback call by name and an array
-///   of arguments.
-class CallbackCall {
-public:
-  CallbackCall(llvm::StringRef Name) : Name(Name) {}
-  CallbackCall() = default;
-
-  std::string Name;
-  std::vector<Argument> Arguments;
-};
-
 /// \brief This class overrides the PPCallbacks class for tracking preprocessor
 ///   activity by means of its callback functions.
 ///
@@ -72,6 +52,13 @@
 /// helpers for recording the trace data, to reduce the coupling between it
 /// and the recorded data structure.
 class PPCallbacksTracker : public clang::PPCallbacks {
+
+private:
+  CallbackCalls &Calls;
+  clang::Preprocessor &PP;
+  ArgTokens CurrArgs;
+
+
 public:
   /// \brief Note that all of the arguments are references, and owned
   /// by the caller.
@@ -78,12 +65,15 @@
   /// \param Ignore - Set of names of callbacks to ignore.
   /// \param CallbackCalls - Trace buffer.
   /// \param PP - The preprocessor.  Needed for getting some argument strings.
-  PPCallbacksTracker(llvm::SmallSet<std::string, 4> &Ignore,
-                     std::vector<CallbackCall> &CallbackCalls,
+  PPCallbacksTracker(CallbackCalls &CallbackCalls,
                      clang::Preprocessor &PP);
 
-  ~PPCallbacksTracker() override;
+  PPCallbacksTracker(PPCallbacksTracker&& o);
 
+  PPCallbacksTracker& operator=(PPCallbacksTracker&& o);
+
+  ~PPCallbacksTracker() { llvm::outs() << "PPCallbacksTracker DTOR\n"; }
+
   // Overidden callback functions.
 
   void FileChanged(clang::SourceLocation Loc,
@@ -134,7 +124,7 @@
                      llvm::ArrayRef<int> Ids) override;
   void PragmaWarningPush(clang::SourceLocation Loc, int Level) override;
   void PragmaWarningPop(clang::SourceLocation Loc) override;
-  void MacroExpands(const clang::Token &MacroNameTok,
+  virtual void MacroExpands(const clang::Token &MacroNameTok,
                     const clang::MacroDefinition &MD, clang::SourceRange Range,
                     const clang::MacroArgs *Args) override;
   void MacroDefined(const clang::Token &MacroNameTok,
@@ -158,90 +148,13 @@
             clang::SourceLocation IfLoc) override;
   void Endif(clang::SourceLocation Loc,
              clang::SourceLocation IfLoc) override;
+  void RecursiveExpansion(const clang::Token& Tok) override;
 
-  // Helper functions.
+  const ArgTokens* GetCurrentArgs() const { return &CurrArgs; }
 
-  /// \brief Start a new callback.
-  void beginCallback(const char *Name);
+  CallbackCalls& GetCalls() const { return Calls; }
 
-  /// \brief Append a string to the top trace item.
-  void append(const char *Str);
+};
 
-  /// \brief Append a bool argument to the top trace item.
-  void appendArgument(const char *Name, bool Value);
 
-  /// \brief Append an int argument to the top trace item.
-  void appendArgument(const char *Name, int Value);
-
-  /// \brief Append a string argument to the top trace item.
-  void appendArgument(const char *Name, const char *Value);
-
-  /// \brief Append a string reference object argument to the top trace item.
-  void appendArgument(const char *Name, llvm::StringRef Value);
-
-  /// \brief Append a string object argument to the top trace item.
-  void appendArgument(const char *Name, const std::string &Value);
-
-  /// \brief Append a token argument to the top trace item.
-  void appendArgument(const char *Name, const clang::Token &Value);
-
-  /// \brief Append an enum argument to the top trace item.
-  void appendArgument(const char *Name, int Value, const char *const Strings[]);
-
-  /// \brief Append a FileID argument to the top trace item.
-  void appendArgument(const char *Name, clang::FileID Value);
-
-  /// \brief Append a FileEntry argument to the top trace item.
-  void appendArgument(const char *Name, const clang::FileEntry *Value);
-
-  /// \brief Append a SourceLocation argument to the top trace item.
-  void appendArgument(const char *Name, clang::SourceLocation Value);
-
-  /// \brief Append a SourceRange argument to the top trace item.
-  void appendArgument(const char *Name, clang::SourceRange Value);
-
-  /// \brief Append a CharSourceRange argument to the top trace item.
-  void appendArgument(const char *Name, clang::CharSourceRange Value);
-
-  /// \brief Append a ModuleIdPath argument to the top trace item.
-  void appendArgument(const char *Name, clang::ModuleIdPath Value);
-
-  /// \brief Append an IdentifierInfo argument to the top trace item.
-  void appendArgument(const char *Name, const clang::IdentifierInfo *Value);
-
-  /// \brief Append a MacroDirective argument to the top trace item.
-  void appendArgument(const char *Name, const clang::MacroDirective *Value);
-
-  /// \brief Append a MacroDefinition argument to the top trace item.
-  void appendArgument(const char *Name, const clang::MacroDefinition &Value);
-
-  /// \brief Append a MacroArgs argument to the top trace item.
-  void appendArgument(const char *Name, const clang::MacroArgs *Value);
-
-  /// \brief Append a Module argument to the top trace item.
-  void appendArgument(const char *Name, const clang::Module *Value);
-
-  /// \brief Append a double-quoted argument to the top trace item.
-  void appendQuotedArgument(const char *Name, const std::string &Value);
-
-  /// \brief Append a double-quoted file path argument to the top trace item.
-  void appendFilePathArgument(const char *Name, llvm::StringRef Value);
-
-  /// \brief Get the raw source string of the range.
-  llvm::StringRef getSourceString(clang::CharSourceRange Range);
-
-  /// \brief Callback trace information.
-  /// We use a reference so the trace will be preserved for the caller
-  /// after this object is destructed.
-  std::vector<CallbackCall> &CallbackCalls;
-
-  /// \brief Names of callbacks to ignore.
-  llvm::SmallSet<std::string, 4> &Ignore;
-
-  /// \brief Inhibit trace while this is set.
-  bool DisableTrace;
-
-  clang::Preprocessor &PP;
-};
-
 #endif // PPTRACE_PPCALLBACKSTRACKER_H
Index: pp-trace/PPTrace.cpp
===================================================================
--- pp-trace/PPTrace.cpp	(revision 302379)
+++ pp-trace/PPTrace.cpp	(working copy)
@@ -46,7 +46,9 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "Utils.h"
 #include "PPCallbacksTracker.h"
+#include "VerboseDecorator.h"
 #include "clang/AST/ASTConsumer.h"
 #include "clang/AST/ASTContext.h"
 #include "clang/AST/RecursiveASTVisitor.h"
@@ -86,6 +88,13 @@
                                          cl::desc("<source0> [... <sourceN>]"),
                                          cl::OneOrMore);
 
+// Option to switch on verbose mode.
+static cl::opt<bool> VerboseMode(
+  "verbose", cl::init(false),
+  cl::desc("Print more information,"
+   " showing expanded macro body in MacroExpands event"
+   " and macro type in MacroDefined."));
+
 // Option to specify a list or one or more callback names to ignore.
 static cl::opt<std::string> IgnoreCallbacks(
     "ignore", cl::init(""),
@@ -107,73 +116,51 @@
 // Consumer is responsible for setting up the callbacks.
 class PPTraceConsumer : public ASTConsumer {
 public:
-  PPTraceConsumer(SmallSet<std::string, 4> &Ignore,
-                  std::vector<CallbackCall> &CallbackCalls, Preprocessor &PP) {
+  PPTraceConsumer(CallbackCalls &CallbackCalls, Preprocessor &PP, bool VerboseMode) {
     // PP takes ownership.
-    PP.addPPCallbacks(llvm::make_unique<PPCallbacksTracker>(Ignore,
-                                                            CallbackCalls, PP));
+    auto Tracker = llvm::make_unique<PPCallbacksTracker>(CallbackCalls, PP);
+    if (VerboseMode) {
+      PP.addPPCallbacks(llvm::make_unique<VerboseDecorator>(CallbackCalls, PP,
+        std::move(Tracker)));
+    }
+    else {
+      PP.addPPCallbacks(std::move(Tracker));
+    }
   }
 };
 
 class PPTraceAction : public SyntaxOnlyAction {
 public:
-  PPTraceAction(SmallSet<std::string, 4> &Ignore,
-                std::vector<CallbackCall> &CallbackCalls)
-      : Ignore(Ignore), CallbackCalls(CallbackCalls) {}
+  PPTraceAction(CallbackCalls &Calls, bool VerboseMode)
+      : Calls(Calls), VerboseMode(VerboseMode) {}
 
 protected:
   std::unique_ptr<clang::ASTConsumer>
   CreateASTConsumer(CompilerInstance &CI, StringRef InFile) override {
-    return llvm::make_unique<PPTraceConsumer>(Ignore, CallbackCalls,
-                                              CI.getPreprocessor());
+    return llvm::make_unique<PPTraceConsumer>(Calls,
+                                              CI.getPreprocessor(), VerboseMode);
   }
 
 private:
-  SmallSet<std::string, 4> &Ignore;
-  std::vector<CallbackCall> &CallbackCalls;
+  CallbackCalls &Calls;
+  bool VerboseMode;
 };
 
 class PPTraceFrontendActionFactory : public FrontendActionFactory {
 public:
-  PPTraceFrontendActionFactory(SmallSet<std::string, 4> &Ignore,
-                               std::vector<CallbackCall> &CallbackCalls)
-      : Ignore(Ignore), CallbackCalls(CallbackCalls) {}
+  PPTraceFrontendActionFactory(CallbackCalls &Calls, bool VerboseMode)
+      : Calls(Calls), VerboseMode(VerboseMode) {}
 
   PPTraceAction *create() override {
-    return new PPTraceAction(Ignore, CallbackCalls);
+    return new PPTraceAction(Calls, VerboseMode);
   }
 
 private:
-  SmallSet<std::string, 4> &Ignore;
-  std::vector<CallbackCall> &CallbackCalls;
+  CallbackCalls &Calls;
+  bool VerboseMode;
 };
 } // namespace
 
-// Output the trace given its data structure and a stream.
-static int outputPPTrace(std::vector<CallbackCall> &CallbackCalls,
-                         llvm::raw_ostream &OS) {
-  // Mark start of document.
-  OS << "---\n";
-
-  for (std::vector<CallbackCall>::const_iterator I = CallbackCalls.begin(),
-                                                 E = CallbackCalls.end();
-       I != E; ++I) {
-    const CallbackCall &Callback = *I;
-    OS << "- Callback: " << Callback.Name << "\n";
-
-    for (auto AI = Callback.Arguments.begin(), AE = Callback.Arguments.end();
-         AI != AE; ++AI) {
-      const Argument &Arg = *AI;
-      OS << "  " << Arg.Name << ": " << Arg.Value << "\n";
-    }
-  }
-
-  // Mark end of document.
-  OS << "...\n";
-
-  return 0;
-}
-
 // Program entry point.
 int main(int Argc, const char **Argv) {
 
@@ -185,10 +172,8 @@
   StringRef(IgnoreCallbacks).split(IgnoreCallbacksStrings, ",",
                                    /*MaxSplit=*/ -1, /*KeepEmpty=*/false);
   SmallSet<std::string, 4> Ignore;
-  for (SmallVector<StringRef, 32>::iterator I = IgnoreCallbacksStrings.begin(),
-                                            E = IgnoreCallbacksStrings.end();
-       I != E; ++I)
-    Ignore.insert(*I);
+  for (auto& CallbackStr : IgnoreCallbacksStrings)
+    Ignore.insert(CallbackStr);
 
   // Create the compilation database.
   SmallString<256> PathBuf;
@@ -197,14 +182,14 @@
   Compilations.reset(
       new FixedCompilationDatabase(Twine(PathBuf), CC1Arguments));
 
-  // Store the callback trace information here.
-  std::vector<CallbackCall> CallbackCalls;
-
   // Create the tool and run the compilation.
   ClangTool Tool(*Compilations, SourcePaths);
-  PPTraceFrontendActionFactory Factory(Ignore, CallbackCalls);
-  int HadErrors = Tool.run(&Factory);
 
+  auto Calls = CallbackCalls(Ignore);
+
+	PPTraceFrontendActionFactory Factory(Calls, VerboseMode);
+  auto HadErrors = Tool.run(&Factory);
+
   // If we had errors, exit early.
   if (HadErrors)
     return HadErrors;
@@ -211,7 +196,7 @@
 
   // Do the output.
   if (!OutputFileName.size()) {
-    HadErrors = outputPPTrace(CallbackCalls, llvm::outs());
+    HadErrors = outputPPTrace(Calls, llvm::outs());
   } else {
     // Set up output file.
     std::error_code EC;
@@ -222,7 +207,7 @@
       return 1;
     }
 
-    HadErrors = outputPPTrace(CallbackCalls, Out.os());
+    HadErrors = outputPPTrace(Calls, Out.os());
 
     // Tell tool_output_file that we want to keep the file.
     if (HadErrors == 0)
Index: pp-trace/Utils.h
===================================================================
--- pp-trace/Utils.h	(nonexistent)
+++ pp-trace/Utils.h	(working copy)
@@ -0,0 +1,79 @@
+#ifndef PPTRACE_UTILS_H
+#define PPTRACE_UTILS_H
+
+#include "CallbackCall.h"
+#include "PPCallbacksTracker.h"
+#include "clang/Lex/Preprocessor.h"
+#include "clang/Lex/MacroArgs.h"
+#include "clang/Basic/SourceManager.h"
+#include <string>
+#include <vector>
+
+// Utility functions.
+
+// Get a "file:line:column" source location string.
+inline std::string getSourceLocationString(const clang::Preprocessor& PP,
+  clang::SourceLocation Loc) {
+  if (Loc.isInvalid())
+    return std::string("(none)");
+
+  if (Loc.isFileID()) {
+    const auto PLoc = PP.getSourceManager().getPresumedLoc(Loc);
+
+    if (PLoc.isInvalid()) {
+      return std::string("(invalid)");
+    }
+
+    std::string Str;
+    llvm::raw_string_ostream SS(Str);
+
+    // The macro expansion and spelling pos is identical for file locs.
+    SS << "\"" << PLoc.getFilename() << ':' << PLoc.getLine() << ':'
+      << PLoc.getColumn() << "\"";
+
+    auto Result = SS.str();
+
+    // YAML treats backslash as escape, so use forward slashes.
+    std::replace(Result.begin(), Result.end(), '\\', '/');
+
+    return Result;
+  }
+
+  return std::string("(nonfile)");
+}
+
+inline const char* getCharacterData(const clang::Preprocessor &PP,
+                                    const clang::SourceLocation& Loc) {
+  return PP.getSourceManager().getCharacterData(Loc);
+}
+
+// Get the raw source string of the range.
+template <typename T>
+inline llvm::StringRef getSourceString(const clang::Preprocessor &PP,
+                                       const T& Range) {
+  const auto B = getCharacterData(PP, Range.getBegin());
+  const auto E = getCharacterData(PP, Range.getEnd());
+  return llvm::StringRef(B, E - B + 1).trim();
+}
+
+// Output the trace given its data structure and a stream.
+inline int outputPPTrace(CallbackCalls &CallbackCalls,
+  llvm::raw_ostream &OS) {
+  // Mark start of document.
+  OS << "---\n";
+
+  for (const auto& Callback : CallbackCalls) {
+    OS << "- Callback: " << Callback.Name << "\n";
+
+    for (const auto& Arg : Callback.Arguments) {
+      OS << "  " << Arg.Name << ": " << Arg.Value << "\n";
+    }
+  }
+
+  // Mark end of document.
+  OS << "...\n";
+
+  return 0;
+}
+
+#endif // PPTRACE_UTILS_H
Index: pp-trace/VerboseDecorator.cpp
===================================================================
--- pp-trace/VerboseDecorator.cpp	(nonexistent)
+++ pp-trace/VerboseDecorator.cpp	(working copy)
@@ -0,0 +1,70 @@
+#include "VerboseDecorator.h"
+#include <numeric>
+
+using namespace llvm;
+using namespace clang;
+
+VerboseDecorator::VerboseDecorator(CallbackCalls& CallbackCalls,
+                                   clang::Preprocessor & PP,
+                                   std::unique_ptr<PPCallbacksTracker> Tracker)
+    : PPCallbacksTracker(CallbackCalls, PP),
+      Tracker(std::move(Tracker)), 
+      PP(PP) {
+  llvm::outs() << "VerboseDecorator CTOR\n";
+}
+
+
+VerboseDecorator::VerboseDecorator(VerboseDecorator&& o)
+    : PPCallbacksTracker(o.Tracker->GetCalls(), o.PP),
+      Tracker(std::move(o.Tracker)),
+      PP(o.PP) {
+
+    llvm::outs() << "VerboseDecorator MOVE CTOR\n";
+}
+
+VerboseDecorator& VerboseDecorator::operator=(VerboseDecorator&& o) {
+    llvm::outs() << "VerboseDecorator MOVE ASSIGN\n";
+    if (this != &o) {
+        Tracker.release();
+        Tracker = std::move(o.Tracker);
+    }
+
+    return *this;
+}
+
+void VerboseDecorator::MacroExpands(const clang::Token &MacroNameTok,
+    const clang::MacroDefinition &MD, clang::SourceRange Range,
+    const clang::MacroArgs *Args) {
+    Tracker->MacroExpands(MacroNameTok, MD, Range, Args);
+
+    const auto DefBody = MD.getMacroInfo()->tokens();
+    auto RawDefBody = std::vector<std::string>(DefBody.size());
+
+    for (const auto& t : DefBody) {
+        auto Begin = getCharacterData(PP, t.getLocation());
+        const auto tok = StringRef(Begin, t.getLength());
+        RawDefBody.push_back(tok);
+    }
+
+    for (const auto &CurrArg : *Tracker->GetCurrentArgs()) {
+        for (auto &BodyToken : RawDefBody) {
+            if (std::get<0>(CurrArg).compare(BodyToken) == 0) {
+                auto ArgTokens = &std::get<1>(CurrArg);
+                BodyToken =
+                std::accumulate(ArgTokens->cbegin(), ArgTokens->cend(), std::string(""));
+            }
+        }
+    }
+
+    Tracker.get()->GetCalls().appendArgument("ExpandedTokens",
+    std::accumulate(RawDefBody.begin(),RawDefBody.end(), std::string("")));
+}
+
+void VerboseDecorator::MacroDefined(const clang::Token &MacroNameTok,
+    const clang::MacroDirective *MD) {
+    Tracker->MacroDefined(MacroNameTok, MD);
+
+    const auto likeness = MD->getDefinition().getMacroInfo()->isObjectLike();
+    Tracker->GetCalls().appendArgument("Likeness", likeness ? "Object" : "Function");
+    Tracker->GetCalls().appendArgument("Loc", MD->getLocation(), PP);
+}
Index: pp-trace/VerboseDecorator.h
===================================================================
--- pp-trace/VerboseDecorator.h	(nonexistent)
+++ pp-trace/VerboseDecorator.h	(working copy)
@@ -0,0 +1,28 @@
+#ifndef PPTRACE_VERBOSE_DECORATOR_H
+#define PPTRACE_VERBOSE_DECORATOR_H
+
+#include "PPCallbacksTracker.h"
+
+class VerboseDecorator : public PPCallbacksTracker {
+public:
+    VerboseDecorator(CallbackCalls& CallbackCalls,
+        clang::Preprocessor &PP, std::unique_ptr<PPCallbacksTracker> Tracker);
+    VerboseDecorator(VerboseDecorator&& o);
+    VerboseDecorator& operator=(VerboseDecorator&& o);
+
+    ~VerboseDecorator() { llvm::outs() << "VerboseDecorator DTOR\n"; }
+
+    void MacroExpands(const clang::Token &MacroNameTok,
+    const clang::MacroDefinition &MD, clang::SourceRange Range,
+    const clang::MacroArgs *Args) override;
+    void MacroDefined(const clang::Token &MacroNameTok,
+    const clang::MacroDirective *MD) override;
+
+private:
+
+    std::unique_ptr<PPCallbacksTracker> Tracker;
+    clang::Preprocessor &PP;
+};
+
+#endif // PPTRACE_VERBOSE_DECORATOR_H
+
Index: test/pp-trace/pp-trace-macro.cpp
===================================================================
--- test/pp-trace/pp-trace-macro.cpp	(revision 302379)
+++ test/pp-trace/pp-trace-macro.cpp	(working copy)
@@ -37,7 +37,6 @@
 // CHECK-NEXT:   MacroNameTok: MACRO
 // CHECK-NEXT:   MacroDefinition: [(local)]
 // CHECK-NEXT:   Range: ["{{.*}}{{[/\\]}}pp-trace-macro.cpp:4:9", "{{.*}}{{[/\\]}}pp-trace-macro.cpp:4:9"]
-// CHECK-NEXT:   Args: (null)
 // CHECK-NEXT: - Callback: Defined
 // CHECK-NEXT:   MacroNameTok: MACRO
 // CHECK-NEXT:   MacroDefinition: [(local)]
@@ -72,7 +71,8 @@
 // CHECK-NEXT:   MacroNameTok: FUNCMACRO
 // CHECK-NEXT:   MacroDefinition: [(local)]
 // CHECK-NEXT:   Range: ["{{.*}}{{[/\\]}}pp-trace-macro.cpp:11:9", "{{.*}}{{[/\\]}}pp-trace-macro.cpp:11:20"]
-// CHECK-NEXT:   Args: [1]
+// CHECK-NEXT:   Args:
+// CHECK-NEXT:   - ARG1: 1
 // CHECK-NEXT: - Callback: MacroDefined
 // CHECK-NEXT:   MacroNameTok: X
 // CHECK-NEXT:   MacroDirective: MD_Define
@@ -86,16 +86,22 @@
 // CHECK-NEXT:   MacroNameTok: X
 // CHECK-NEXT:   MacroDefinition: [(local)]
 // CHECK-NEXT:   Range: ["{{.*}}{{[/\\]}}pp-trace-macro.cpp:15:1", "{{.*}}{{[/\\]}}pp-trace-macro.cpp:15:1"]
-// CHECK-NEXT:   Args: (null)
+// CHECK-NEXT: - Callback: RecursiveExpansion
+// CHECK-NEXT:   MacroNameTok: X_IMPL
 // CHECK-NEXT: - Callback: MacroExpands
 // CHECK-NEXT:   MacroNameTok: X_IMPL
 // CHECK-NEXT:   MacroDefinition: [(local)]
 // CHECK-NEXT:   Range: [(nonfile), (nonfile)]
-// CHECK-NEXT:   Args: [a <plus> y, b]
+// CHECK-NEXT:   Args:
+// CHECK-NEXT:   - p1: a+y
+// CHECK-NEXT:   - p2: b
+// CHECK-NEXT: - Callback: RecursiveExpansion
+// CHECK-NEXT:   MacroNameTok: X_IMPL2
 // CHECK-NEXT: - Callback: MacroExpands
 // CHECK-NEXT:   MacroNameTok: X_IMPL2
 // CHECK-NEXT:   MacroDefinition: [(local)]
 // CHECK-NEXT:   Range: [(nonfile), (nonfile)]
-// CHECK-NEXT:   Args: [c]
+// CHECK-NEXT:   Args:
+// CHECK-NEXT:   - p1: c
 // CHECK-NEXT: - Callback: EndOfMainFile
 // CHECK-NEXT: ...
Index: test/pp-trace/pp-trace-verbose.cpp
===================================================================
--- test/pp-trace/pp-trace-verbose.cpp	(nonexistent)
+++ test/pp-trace/pp-trace-verbose.cpp	(working copy)
@@ -0,0 +1,163 @@
+// RUN: pp-trace -verbose -ignore FileChanged %s -undef -target x86_64 -std=c++11 | FileCheck --strict-whitespace %s
+
+#define ZERO 0
+#define TWO 2
+#define ARG(a) a
+#define ARGS(...) __VA_ARGS__
+#define MUL(LHS, RHS) ((LHS) * (RHS))
+#define SQ(a) (MUL(a, a))
+#define ARGS2(a, ...) a + ARGS(__VA_ARGS__)
+
+int main() {
+    return ARGS(MUL(ZERO, SQ(TWO - ZERO))) + ARGS2(2, 3, 4, 5, 6);
+}
+
+// CHECK: ---
+// CHECK-NEXT: - Callback: MacroDefined
+// CHECK:        MacroNameTok: __STDC__
+// CHECK-NEXT:   MacroDirective: MD_Define
+// CHECK-NEXT:   Likeness: Object
+// CHECK-NEXT:   Loc: "<built-in>:{{[0-9+]}}:{{[0-9+]}}"
+// CHECK-NEXT: - Callback: MacroDefined
+// CHECK:        MacroNameTok: __STDC_HOSTED__
+// CHECK-NEXT:   MacroDirective: MD_Define
+// CHECK-NEXT:   Likeness: Object
+// CHECK-NEXT:   Loc: "<built-in>:{{[0-9+]}}:{{[0-9+]}}"
+// CHECK-NEXT: - Callback: MacroDefined
+// CHECK-NEXT:   MacroNameTok: __cplusplus
+// CHECK-NEXT:   MacroDirective: MD_Define
+// CHECK-NEXT:   Likeness: Object
+// CHECK-NEXT:   Loc: "<built-in>:{{[0-9+]}}:{{[0-9+]}}"
+// CHECK-NEXT: - Callback: MacroDefined
+// CHECK:        MacroNameTok: __STDC_UTF_16__
+// CHECK-NEXT:   MacroDirective: MD_Define
+// CHECK-NEXT:   Likeness: Object
+// CHECK-NEXT:   "<built-in>:{{[0-9+]}}:{{[0-9+]}}"
+// CHECK-NEXT: - Callback: MacroDefined
+// CHECK:        MacroNameTok: __STDC_UTF_32__
+// CHECK-NEXT:   MacroDirective: MD_Define
+// CHECK-NEXT:   Likeness: Object
+// CHECK-NEXT:   "<built-in>:{{[0-9+]}}:{{[0-9+]}}"
+// CHECK-NEXT: - Callback: MacroDefined
+// CHECK-NEXT:   MacroNameTok: ZERO
+// CHECK-NEXT:   MacroDirective: MD_Define
+// CHECK-NEXT:   Likeness: Object
+// CHECK-NEXT:   Loc: "{{.*}}{{[/\\]}}pp-trace-verbose.cpp:3:9"
+// CHECK-NEXT: - Callback: MacroDefined
+// CHECK-NEXT:   MacroNameTok: TWO
+// CHECK-NEXT:   MacroDirective: MD_Define
+// CHECK-NEXT:   Likeness: Object
+// CHECK-NEXT:   Loc: "{{.*}}{{[/\\]}}pp-trace-verbose.cpp:4:9"
+// CHECK-NEXT: - Callback: MacroDefined
+// CHECK-NEXT:   MacroNameTok: ARG
+// CHECK-NEXT:   MacroDirective: MD_Define
+// CHECK-NEXT:   Likeness: Function
+// CHECK-NEXT:   Loc: "{{.*}}{{[/\\]}}pp-trace-verbose.cpp:5:9"
+// CHECK-NEXT: - Callback: MacroDefined
+// CHECK-NEXT:   MacroNameTok: ARGS
+// CHECK-NEXT:   MacroDirective: MD_Define
+// CHECK-NEXT:   Likeness: Function
+// CHECK-NEXT:   Loc: "{{.*}}{{[/\\]}}pp-trace-verbose.cpp:6:9"
+// CHECK-NEXT: - Callback: MacroDefined
+// CHECK-NEXT:   MacroNameTok: MUL
+// CHECK-NEXT:   MacroDirective: MD_Define
+// CHECK-NEXT:   Likeness: Function
+// CHECK-NEXT:   Loc: "{{.*}}{{[/\\]}}pp-trace-verbose.cpp:7:9"
+// CHECK-NEXT: - Callback: MacroDefined
+// CHECK-NEXT:   MacroNameTok: SQ
+// CHECK-NEXT:   MacroDirective: MD_Define
+// CHECK-NEXT:   Likeness: Function
+// CHECK-NEXT:   Loc: "{{.*}}{{[/\\]}}pp-trace-verbose.cpp:8:9"
+// CHECK-NEXT: - Callback: MacroDefined
+// CHECK-NEXT:   MacroNameTok: ARGS2
+// CHECK-NEXT:   MacroDirective: MD_Define
+// CHECK-NEXT:   Likeness: Function
+// CHECK-NEXT:   Loc: "{{.*}}{{[/\\]}}pp-trace-verbose.cpp:9:9"
+// CHECK-NEXT: - Callback: MacroExpands
+// CHECK-NEXT:   MacroNameTok: ARGS
+// CHECK-NEXT:   MacroDefinition: [(local)]
+// CHECK-NEXT:   Range: ["{{.*}}{{[/\\]}}pp-trace-verbose.cpp:12:12", "{{.*}}{{[/\\]}}pp-trace-verbose.cpp:12:42"]
+// CHECK-NEXT:   Args:
+// CHECK-NEXT:   - __VA_ARGS__: MUL(ZERO,SQ(TWO-ZERO))
+// CHECK-NEXT:   ExpandedTokens: MUL(ZERO,SQ(TWO-ZERO))
+// CHECK-NEXT: - Callback: RecursiveExpansion
+// CHECK-NEXT:   MacroNameTok: MUL
+// CHECK-NEXT: - Callback: RecursiveExpansion
+// CHECK-NEXT:   MacroNameTok: ZERO
+// CHECK-NEXT: - Callback: RecursiveExpansion
+// CHECK-NEXT:   MacroNameTok: SQ
+// CHECK-NEXT: - Callback: RecursiveExpansion
+// CHECK-NEXT:   MacroNameTok: TWO
+// CHECK-NEXT: - Callback: RecursiveExpansion
+// CHECK-NEXT:   MacroNameTok: ZERO
+// CHECK-NEXT: - Callback: MacroExpands
+// CHECK-NEXT:   MacroNameTok: MUL
+// CHECK-NEXT:   MacroDefinition: [(local)]
+// CHECK-NEXT:   Range: ["{{.*}}{{[/\\]}}pp-trace-verbose.cpp:12:17", "{{.*}}{{[/\\]}}pp-trace-verbose.cpp:12:41"]
+// CHECK-NEXT:   Args:
+// CHECK-NEXT:   - LHS: ZERO
+// CHECK-NEXT:   - RHS: SQ(TWO-ZERO)
+// CHECK-NEXT:   ExpandedTokens: ((ZERO)*(SQ(TWO-ZERO)))
+// CHECK-NEXT: - Callback: RecursiveExpansion
+// CHECK-NEXT:   MacroNameTok: ZERO
+// CHECK-NEXT: - Callback: MacroExpands
+// CHECK-NEXT:   MacroNameTok: ZERO
+// CHECK-NEXT:   MacroDefinition: [(local)]
+// CHECK-NEXT:   Range: ["{{.*}}{{[/\\]}}pp-trace-verbose.cpp:12:21", "{{.*}}{{[/\\]}}pp-trace-verbose.cpp:12:21"]
+// CHECK-NEXT:   ExpandedTokens: 0
+// CHECK-NEXT: - Callback: RecursiveExpansion
+// CHECK-NEXT:   MacroNameTok: SQ
+// CHECK-NEXT: - Callback: RecursiveExpansion
+// CHECK-NEXT:   MacroNameTok: TWO
+// CHECK-NEXT: - Callback: RecursiveExpansion
+// CHECK-NEXT:   MacroNameTok: ZERO
+// CHECK-NEXT: - Callback: MacroExpands
+// CHECK-NEXT:   MacroNameTok: SQ
+// CHECK-NEXT:   MacroDefinition: [(local)]
+// CHECK-NEXT:   Range: ["{{.*}}{{[/\\]}}pp-trace-verbose.cpp:12:27", "{{.*}}{{[/\\]}}pp-trace-verbose.cpp:12:40"]
+// CHECK-NEXT:   Args:
+// CHECK-NEXT:   - a: TWO-ZERO
+// CHECK-NEXT:   ExpandedTokens: (MUL(TWO-ZERO,TWO-ZERO))
+// CHECK-NEXT: - Callback: RecursiveExpansion
+// CHECK-NEXT:   MacroNameTok: TWO
+// CHECK-NEXT: - Callback: MacroExpands
+// CHECK-NEXT:   MacroNameTok: TWO
+// CHECK-NEXT:   MacroDefinition: [(local)]
+// CHECK-NEXT:   Range: ["{{.*}}{{[/\\]}}pp-trace-verbose.cpp:12:30", "{{.*}}{{[/\\]}}pp-trace-verbose.cpp:12:30"]
+// CHECK-NEXT:   ExpandedTokens: 2
+// CHECK-NEXT: - Callback: RecursiveExpansion
+// CHECK-NEXT:   MacroNameTok: ZERO
+// CHECK-NEXT: - Callback: MacroExpands
+// CHECK-NEXT:   MacroNameTok: ZERO
+// CHECK-NEXT:   MacroDefinition: [(local)]
+// CHECK-NEXT:   Range: ["{{.*}}{{[/\\]}}pp-trace-verbose.cpp:12:36", "{{.*}}{{[/\\]}}pp-trace-verbose.cpp:12:36"]
+// CHECK-NEXT:   ExpandedTokens: 0
+// CHECK-NEXT: - Callback: RecursiveExpansion
+// CHECK-NEXT:   MacroNameTok: MUL
+// CHECK-NEXT: - Callback: MacroExpands
+// CHECK-NEXT:   MacroNameTok: MUL
+// CHECK-NEXT:   MacroDefinition: [(local)]
+// CHECK-NEXT:   Range: [(nonfile), (nonfile)]
+// CHECK-NEXT:   Args:
+// CHECK-NEXT:   - LHS: 2-0
+// CHECK-NEXT:   - RHS: 2-0
+// CHECK-NEXT:   ExpandedTokens: ((2-0)*(2-0))
+// CHECK-NEXT: - Callback: MacroExpands
+// CHECK-NEXT:   MacroNameTok: ARGS2
+// CHECK-NEXT:   MacroDefinition: [(local)]
+// CHECK-NEXT:   Range: ["{{.*}}{{[/\\]}}pp-trace-verbose.cpp:12:46", "{{.*}}{{[/\\]}}pp-trace-verbose.cpp:12:65"]
+// CHECK-NEXT:   Args:
+// CHECK-NEXT:   - a: 2
+// CHECK-NEXT:   - __VA_ARGS__: 3,4,5,6
+// CHECK-NEXT:   ExpandedTokens: 2+ARGS(3,4,5,6)
+// CHECK-NEXT: - Callback: RecursiveExpansion
+// CHECK-NEXT:   MacroNameTok: ARGS
+// CHECK-NEXT: - Callback: MacroExpands
+// CHECK-NEXT:   MacroNameTok: ARGS
+// CHECK-NEXT:   MacroDefinition: [(local)]
+// CHECK-NEXT:   Range: [(nonfile), (nonfile)]
+// CHECK-NEXT:   Args:
+// CHECK-NEXT:   - __VA_ARGS__: 3,4,5,6
+// CHECK-NEXT:   ExpandedTokens: 3,4,5,6
+// CHECK-NEXT: - Callback: EndOfMainFile
+// CHECK-NEXT: ...
\ No newline at end of file
